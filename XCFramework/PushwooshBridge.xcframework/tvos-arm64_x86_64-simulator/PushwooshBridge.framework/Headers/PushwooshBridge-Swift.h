#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
#ifndef PUSHWOOSHBRIDGE_SWIFT_H
#define PUSHWOOSHBRIDGE_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="PushwooshBridge",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
@class UIColor;
@class UIFont;
@class NSObject;
enum PWForegroundPushStyle : NSInteger;
enum PWForegroundPushHapticFeedback : NSInteger;
enum PWForegroundPushDisappearedAnimation : NSInteger;

/// Protocol for handling custom foreground pushes in Pushwoosh.
/// Allows configuration of appearance, haptic feedback, and tap callbacks for foreground push notifications.
SWIFT_PROTOCOL("_TtP15PushwooshBridge16PWForegroundPush_")
@protocol PWForegroundPush
/// Custom gradient colors for the push background.
/// If set to nil, the default gradient is used.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSArray<UIColor *> * _Nullable gradientColors;)
+ (NSArray<UIColor *> * _Nullable)gradientColors SWIFT_WARN_UNUSED_RESULT;
+ (void)setGradientColors:(NSArray<UIColor *> * _Nullable)newValue;
/// Background color for the push.
/// If nil and <code>gradientColors</code> is not set, the default gradient is used.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIColor * _Nullable backgroundColor;)
+ (UIColor * _Nullable)backgroundColor SWIFT_WARN_UNUSED_RESULT;
+ (void)setBackgroundColor:(UIColor * _Nullable)newValue;
/// Determines whether to use the default push animation when displaying a foreground push.
/// If <code>true</code>, the push notification will animate in with a slide and wave effect.
/// If <code>false</code>, the push will appear instantly without animation.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL usePushAnimation;)
+ (BOOL)usePushAnimation SWIFT_WARN_UNUSED_RESULT;
+ (void)setUsePushAnimation:(BOOL)newValue;
/// Color for the push title text.
/// Defaults to system white if nil.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIColor * _Nullable titlePushColor;)
+ (UIColor * _Nullable)titlePushColor SWIFT_WARN_UNUSED_RESULT;
+ (void)setTitlePushColor:(UIColor * _Nullable)newValue;
/// The font used for the title text in a foreground push notification.
/// Set this property to customize the appearance of the title.
/// If <code>nil</code>, the default bold system font of size 18 will be used.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIFont * _Nullable titlePushFont;)
+ (UIFont * _Nullable)titlePushFont SWIFT_WARN_UNUSED_RESULT;
+ (void)setTitlePushFont:(UIFont * _Nullable)newValue;
/// The font used for the message body text in a foreground push notification.
/// Set this property to customize the appearance of the message text.
/// If <code>nil</code>, the default system font will be used.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIFont * _Nullable messagePushFont;)
+ (UIFont * _Nullable)messagePushFont SWIFT_WARN_UNUSED_RESULT;
+ (void)setMessagePushFont:(UIFont * _Nullable)newValue;
/// Color for the push message text.
/// Defaults to system white if nil.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIColor * _Nullable messagePushColor;)
+ (UIColor * _Nullable)messagePushColor SWIFT_WARN_UNUSED_RESULT;
+ (void)setMessagePushColor:(UIColor * _Nullable)newValue;
/// Enables or disables the Liquid Glass style for foreground push notifications.
/// Set this property to <code>true</code> to use the animated Liquid Glass effect (iOS 26+),
/// or <code>false</code> to use the standard push appearance.
/// Note:
/// <ul>
///   <li>
///     If this flag is enabled but the user’s system version is lower than iOS 26,
///     a regular UIView-based push will be shown instead.
///   </li>
///   <li>
///     If your project is compiled with a Swift version <em>lower than 5.13</em>, the Liquid Glass
///     effect will not be available at all — even on iOS 26. In that case, a blurred
///     <code>UIVisualEffectView</code> (with UIBlurEffect) will be used instead on all devices.
///   </li>
/// </ul>
/// In summary:
/// <ul>
///   <li>
///     Swift 5.13+ + iOS 26 → Liquid Glass
///   </li>
///   <li>
///     Swift 5.13+ + iOS < 26 → Standard UIView
///   </li>
///   <li>
///     Swift < 5.13 → Always blurred view (no Liquid Glass support)
///   </li>
/// </ul>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL useLiquidView;)
+ (BOOL)useLiquidView SWIFT_WARN_UNUSED_RESULT;
+ (void)setUseLiquidView:(BOOL)newValue;
/// Callback triggered when the user taps on the push notification.
/// \param userInfo Dictionary containing push payload data.
///
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) void (^ _Nullable didTapForegroundPush)(NSDictionary * _Nonnull);)
+ (void (^ _Nullable)(NSDictionary * _Nonnull))didTapForegroundPush SWIFT_WARN_UNUSED_RESULT;
+ (void)setDidTapForegroundPush:(void (^ _Nullable)(NSDictionary * _Nonnull))newValue;
/// Configure a foreground push with the specified style, duration, and haptic feedback.
/// Call this method during application initialization to set up the foreground push behavior.
/// \param style Display style of the push.
///
/// \param duration Duration (in seconds) to show the push.
///
/// \param vibration Haptic feedback type for the push.
///
/// \param disappearedPushAnimation The animation to use when the push disappears. Use <code>.balls</code> for a particle-like explosion effect, or <code>.regularPush</code> to mimic the standard upward push disappearance.
///
+ (void)foregroundNotificationWithStyle:(enum PWForegroundPushStyle)style duration:(NSInteger)duration vibration:(enum PWForegroundPushHapticFeedback)vibration disappearedPushAnimation:(enum PWForegroundPushDisappearedAnimation)disappearedPushAnimation;
/// Show a foreground push with the specified payload.
/// \param userInfo Dictionary containing push payload data.
///
+ (void)showForegroundPushWithUserInfo:(NSDictionary * _Nonnull)userInfo;
@end

/// Enum representing the disappearance animation of a foreground push notification.
/// <ul>
///   <li>
///     <code>balls</code>: The push notification explodes into small balls when disappearing.
///   </li>
///   <li>
///     <code>regularPush</code>: The push notification moves upward and disappears, mimicking the standard push behavior.
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, PWForegroundPushDisappearedAnimation, open) {
  PWForegroundPushDisappearedAnimationBalls = 0,
  PWForegroundPushDisappearedAnimationRegularPush = 1,
};

typedef SWIFT_ENUM(NSInteger, PWForegroundPushHapticFeedback, open) {
  PWForegroundPushHapticFeedbackNone = 0,
  PWForegroundPushHapticFeedbackLight = 1,
  PWForegroundPushHapticFeedbackMedium = 2,
  PWForegroundPushHapticFeedbackHeavy = 3,
  PWForegroundPushHapticFeedbackSoft = 4,
  PWForegroundPushHapticFeedbackRigid = 5,
  PWForegroundPushHapticFeedbackNotification = 6,
};


SWIFT_CLASS("_TtC15PushwooshBridge20PWForegroundPushStub")
@interface PWForegroundPushStub : NSObject <PWForegroundPush>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSArray<UIColor *> * _Nullable gradientColors;)
+ (NSArray<UIColor *> * _Nullable)gradientColors SWIFT_WARN_UNUSED_RESULT;
+ (void)setGradientColors:(NSArray<UIColor *> * _Nullable)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIColor * _Nullable backgroundColor;)
+ (UIColor * _Nullable)backgroundColor SWIFT_WARN_UNUSED_RESULT;
+ (void)setBackgroundColor:(UIColor * _Nullable)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL usePushAnimation;)
+ (BOOL)usePushAnimation SWIFT_WARN_UNUSED_RESULT;
+ (void)setUsePushAnimation:(BOOL)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIColor * _Nullable titlePushColor;)
+ (UIColor * _Nullable)titlePushColor SWIFT_WARN_UNUSED_RESULT;
+ (void)setTitlePushColor:(UIColor * _Nullable)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIColor * _Nullable messagePushColor;)
+ (UIColor * _Nullable)messagePushColor SWIFT_WARN_UNUSED_RESULT;
+ (void)setMessagePushColor:(UIColor * _Nullable)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIFont * _Nullable titlePushFont;)
+ (UIFont * _Nullable)titlePushFont SWIFT_WARN_UNUSED_RESULT;
+ (void)setTitlePushFont:(UIFont * _Nullable)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIFont * _Nullable messagePushFont;)
+ (UIFont * _Nullable)messagePushFont SWIFT_WARN_UNUSED_RESULT;
+ (void)setMessagePushFont:(UIFont * _Nullable)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL useLiquidView;)
+ (BOOL)useLiquidView SWIFT_WARN_UNUSED_RESULT;
+ (void)setUseLiquidView:(BOOL)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) void (^ _Nullable didTapForegroundPush)(NSDictionary * _Nonnull);)
+ (void (^ _Nullable)(NSDictionary * _Nonnull))didTapForegroundPush SWIFT_WARN_UNUSED_RESULT;
+ (void)setDidTapForegroundPush:(void (^ _Nullable)(NSDictionary * _Nonnull))value;
+ (void)showForegroundPushWithUserInfo:(NSDictionary * _Nonnull)userInfo;
+ (Class _Nonnull)foregroundPush SWIFT_WARN_UNUSED_RESULT;
+ (void)foregroundNotificationWithStyle:(enum PWForegroundPushStyle)style duration:(NSInteger)duration vibration:(enum PWForegroundPushHapticFeedback)vibration disappearedPushAnimation:(enum PWForegroundPushDisappearedAnimation)disappearedPushAnimation;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, PWForegroundPushStyle, open) {
  PWForegroundPushStyleStyle1 = 0,
};

@class NSString;

SWIFT_PROTOCOL("_TtP15PushwooshBridge16PWLiveActivities_")
@protocol PWLiveActivities
/// Sends push to start live activity token to the server.
/// Call this method when you want to initiate live activity via push notification
/// This method should be called when you want to send the push token to the server in order to initiate a live activity via a push notification. Once the token is sent to the server, it allows you to remotely trigger and manage the live activity through push notifications.
/// Example:
/// \code
/// if #available(iOS 17.2, *) {
///         Task {
///             for await data in Activity<LiveActivityAttributes>.pushToStartTokenUpdates {
///                 let token = data.map { String(format: "%02x", $0) }.joined()
///                 do {
///                     try await Pushwoosh.LiveActivities.sendPush(toStartLiveActivityToken: "token")
///                 } catch {
///                     print("Error sending push to start live activity: \(error)")
///                 }
///            }
///        }
///  }
///
/// \endcode
+ (void)sendPushToStartLiveActivityWithToken:(NSString * _Nonnull)token;
+ (void)sendPushToStartLiveActivityWithToken:(NSString * _Nonnull)token completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Sends live activity token to the server.
/// Call this method when you create a live activity.
/// This method sends the activity token and activity ID to the server when a live activity is started on the user’s device. It handles the asynchronous request to notify the server about the new activity. Ensure that both the token and activity ID are valid before calling this method to avoid potential issues.
/// Example:
/// \code
/// do {
///     let activity = try Activity<PushwooshAppAttributes>.request(
///         attributes: attributes,
///         contentState: contentState,
///         pushType: .token)
///     
///     for await data in activity.pushTokenUpdates {
///         guard let token = data.map { String(format: "%02x", $0) }.joined(separator: "") else {
///             continue
///         }
///         
///         do {
///             try await Pushwoosh.LiveActivities.startLiveActivity(token: "token", activityId: "activityId")
///             return token
///         } catch {
///             print("Failed to start live activity with token \(token): \(error.localizedDescription)")
///             return nil
///         }
///     }
///     return nil
/// } catch {
///     print("Error requesting activity: \(error.localizedDescription)")
///     return nil
/// }
///
/// \endcode@param token Activity token
/// @param activityId Activity ID for updating Live Activities by segments
+ (void)startLiveActivityWithToken:(NSString * _Nonnull)token activityId:(NSString * _Nonnull)activityId;
+ (void)startLiveActivityWithToken:(NSString * _Nonnull)token activityId:(NSString * _Nonnull)activityId completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Call this method when you finish working with the live activity and want to notify the server that the activity has ended.
/// This does <em>not</em> stop or remove the activity from the device itself; it simply informs the server that the activity has been completed.
/// This method should be called when you finish working with the live activity. It sends a request to the server to notify that the live activity has been completed. Typically, this is called when the user has completed the task or interaction that was being tracked by the live activity.
/// The server can then process this information and take appropriate actions based on the completion status of the live activity.
/// Example:
/// \code
/// func end(activity: Activity<PushwooshAppAttributes>) {
///     Task {
///         await activity.end(dismissalPolicy: .immediate)
///         try await Pushwoosh.LiveActivities.stopLiveActivity()
///     }
/// }
///
/// \endcode
+ (void)stopLiveActivity;
+ (void)stopLiveActivityWithCompletion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Call this method when you finish working with the live activity and want to notify the server that the activity has ended.
/// This does <em>not</em> stop or remove the activity from the device itself; it simply informs the server that the activity has been completed.
/// This method should be called when you finish working with the live activity. It sends a request to the server to notify that the live activity has been completed. Typically, this is called when the user has completed the task or interaction that was being tracked by the live activity.
/// The server can then process this information and take appropriate actions based on the completion status of the live activity.
/// The <code>activityId</code> is a unique identifier for the live activity instance. It is used to reference the specific activity that is being completed. This ID should be passed to the server so it can associate the completion notification with the correct live activity.
/// Example:
/// \code
/// func end(activity: Activity<PushwooshAppAttributes>) {
///     Task {
///         await activity.end(dismissalPolicy: .immediate)
///         try await Pushwoosh.LiveActivities.stopLiveActivity(activityId: "activityId")
///     }
/// }
///
/// \endcode
+ (void)stopLiveActivityWithActivityId:(NSString * _Nonnull)activityId;
+ (void)stopLiveActivityWithActivityId:(NSString * _Nonnull)activityId completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
@end


SWIFT_CLASS("_TtC15PushwooshBridge20PWStubLiveActivities")
@interface PWStubLiveActivities : NSObject <PWLiveActivities>
+ (Class _Nonnull)liveActivities SWIFT_WARN_UNUSED_RESULT;
+ (void)sendPushToStartLiveActivityWithToken:(NSString * _Nonnull)token;
+ (void)sendPushToStartLiveActivityWithToken:(NSString * _Nonnull)token completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
+ (void)startLiveActivityWithToken:(NSString * _Nonnull)token activityId:(NSString * _Nonnull)activityId;
+ (void)startLiveActivityWithToken:(NSString * _Nonnull)token activityId:(NSString * _Nonnull)activityId completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
+ (void)stopLiveActivity;
+ (void)stopLiveActivityWithCompletion:(void (^ _Nonnull)(NSError * _Nullable))completion;
+ (void)stopLiveActivityWithActivityId:(NSString * _Nonnull)activityId;
+ (void)stopLiveActivityWithActivityId:(NSString * _Nonnull)activityId completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// Animation types for dismissing rich media content on tvOS.
typedef SWIFT_ENUM(NSInteger, PWTVOSRichMediaDismissAnimation, open) {
/// No animation, content disappears immediately (default)
  PWTVOSRichMediaDismissAnimationNone = 0,
/// Content slides out to the top of the screen
  PWTVOSRichMediaDismissAnimationToTop = 1,
/// Content slides out to the bottom of the screen
  PWTVOSRichMediaDismissAnimationToBottom = 2,
/// Content slides out to the left side of the screen
  PWTVOSRichMediaDismissAnimationToLeft = 3,
/// Content slides out to the right side of the screen
  PWTVOSRichMediaDismissAnimationToRight = 4,
};

/// Position options for displaying rich media content on tvOS.
typedef SWIFT_ENUM(NSInteger, PWTVOSRichMediaPosition, open) {
/// Content positioned at the center of the screen (default)
  PWTVOSRichMediaPositionCenter = 0,
/// Content positioned at the left side of the screen
  PWTVOSRichMediaPositionLeft = 1,
/// Content positioned at the right side of the screen
  PWTVOSRichMediaPositionRight = 2,
/// Content positioned at the top of the screen
  PWTVOSRichMediaPositionTop = 3,
/// Content positioned at the bottom of the screen
  PWTVOSRichMediaPositionBottom = 4,
};

/// Animation types for presenting rich media content on tvOS.
typedef SWIFT_ENUM(NSInteger, PWTVOSRichMediaPresentAnimation, open) {
/// No animation, content appears immediately (default)
  PWTVOSRichMediaPresentAnimationNone = 0,
/// Content slides in from the top of the screen
  PWTVOSRichMediaPresentAnimationFromTop = 1,
/// Content slides in from the bottom of the screen
  PWTVOSRichMediaPresentAnimationFromBottom = 2,
/// Content slides in from the left side of the screen
  PWTVOSRichMediaPresentAnimationFromLeft = 3,
/// Content slides in from the right side of the screen
  PWTVOSRichMediaPresentAnimationFromRight = 4,
};

@class NSData;

/// Protocol for handling tvOS-specific features in Pushwoosh.
/// This protocol provides an interface for tvOS-specific functionality that can be
/// optionally included in the project. If the PushwooshTVOS module is not linked,
/// a stub implementation will be used instead.
SWIFT_PROTOCOL("_TtP15PushwooshBridge6PWTVoS_")
@protocol PWTVoS
/// Sets the Pushwoosh application code for tvOS.
/// This method must be called before registering for push notifications.
/// The app code can be found in your Pushwoosh Control Panel.
/// Example:
/// \code
/// Pushwoosh.TVoS.setAppCode("XXXXX-XXXXX")
///
/// \endcode\param appCode The Pushwoosh application identifier.
///
+ (void)setAppCode:(NSString * _Nonnull)appCode;
/// Registers for tvOS push notifications.
/// This method requests push notification authorization and registers the device
/// for remote notifications on tvOS.
+ (void)registerForTvPushNotifications;
/// Registers the tvOS device for push notifications with the Pushwoosh server.
/// Call this method after receiving a device token from Apple Push Notification service.
/// This method sends the device token to Pushwoosh servers to enable push notifications.
/// Example:
/// \code
/// func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
///     Pushwoosh.TVoS.registerForTvPushNotifications(withToken: deviceToken) { error in
///         if let error = error {
///             print("Failed to register: \(error)")
///         } else {
///             print("Successfully registered for push notifications")
///         }
///     }
/// }
///
/// \endcode\param token The device token received from APNs in <code>application(_:didRegisterForRemoteNotificationsWithDeviceToken:)</code>.
///
/// \param completion Optional completion handler called when registration completes. The handler receives an error parameter if registration fails, or nil on success.
///
+ (void)registerForTvPushNotificationsWithToken:(NSData * _Nonnull)token completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Unregisters the tvOS device from receiving push notifications.
/// This method removes the device registration from Pushwoosh servers.
/// The device will no longer receive push notifications until it registers again.
/// Example:
/// \code
/// Pushwoosh.TVoS.unregisterForTvPushNotifications { error in
///     if let error = error {
///         print("Failed to unregister: \(error)")
///     } else {
///         print("Successfully unregistered from push notifications")
///     }
/// }
///
/// \endcode\param completion Optional completion handler called when unregistration completes. The handler receives an error parameter if unregistration fails, or nil on success.
///
+ (void)unregisterForTvPushNotificationsWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Handles the device token received from tvOS push registration.
/// \param deviceToken The device token data received from APNs.
///
+ (void)handleTvPushToken:(NSData * _Nonnull)deviceToken;
/// Handles push registration failure on tvOS.
/// Call this method from application:didFailToRegisterForRemoteNotificationsWithError:
/// to log and handle registration errors.
/// \param error The error that occurred during registration.
///
+ (void)handleTvPushRegistrationFailure:(NSError * _Nonnull)error;
/// Handles incoming push notification on tvOS.
/// Call this method from application:didReceiveRemoteNotification:fetchCompletionHandler:
/// to process incoming push notifications.
/// \param userInfo Dictionary containing push payload data.
///
/// \param completionHandler Completion handler to call when processing is complete.
///
+ (void)handleTvPushReceivedWithUserInfo:(NSDictionary * _Nonnull)userInfo completionHandler:(void (^ _Nonnull)(UIBackgroundFetchResult))completionHandler;
/// Handles incoming push notifications with rich media content for tvOS.
/// Call this method to process push notifications that may contain rich media content.
/// If the notification contains rich media, it will be displayed automatically.
/// Example:
/// \code
/// func application(_ application: UIApplication,
///                  didReceiveRemoteNotification userInfo: [AnyHashable: Any],
///                  fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
///     if Pushwoosh.TVoS.handleTVOSPush(userInfo: userInfo) {
///         completionHandler(.newData)
///     } else {
///         completionHandler(.noData)
///     }
/// }
///
/// \endcode\param userInfo The push notification payload received from APNs.
///
///
/// returns:
/// <code>true</code> if the notification contains rich media and was handled, <code>false</code> otherwise.
+ (BOOL)handleTVOSPushWithUserInfo:(NSDictionary * _Nonnull)userInfo SWIFT_WARN_UNUSED_RESULT;
/// Configures rich media presentation, positioning, and dismissal animations for tvOS.
/// This method allows you to customize how rich media content appears, where it’s positioned,
/// and how it disappears on screen. You can choose from different animation directions,
/// screen positions, or disable animation entirely.
/// Example:
/// \code
/// // Configure rich media to appear on the left, slide in from bottom and slide out to left
/// Pushwoosh.TVoS.configureRichMediaWith(position: .left, presentAnimation: .fromBottom, dismissAnimation: .toLeft)
///
/// // Only configure position and present animation (dismiss will use .none)
/// Pushwoosh.TVoS.configureRichMediaWith(position: .right, presentAnimation: .fromTop, dismissAnimation: .none)
///
/// \endcodeNote: This configuration applies to all subsequent rich media presentations until changed.
/// \param position The screen position where rich media content will be displayed.
/// Available options:
/// <ul>
///   <li>
///     <code>.center</code> - Content positioned at the center of the screen (default)
///   </li>
///   <li>
///     <code>.left</code> - Content positioned at the left side of the screen
///   </li>
///   <li>
///     <code>.right</code> - Content positioned at the right side of the screen
///   </li>
///   <li>
///     <code>.top</code> - Content positioned at the top of the screen
///   </li>
///   <li>
///     <code>.bottom</code> - Content positioned at the bottom of the screen
///   </li>
/// </ul>
///
/// \param presentAnimation The animation type to use when presenting rich media.
/// Available options:
/// <ul>
///   <li>
///     <code>.none</code> - No animation, content appears immediately (default)
///   </li>
///   <li>
///     <code>.fromTop</code> - Content slides in from the top of the screen
///   </li>
///   <li>
///     <code>.fromBottom</code> - Content slides in from the bottom of the screen
///   </li>
///   <li>
///     <code>.fromLeft</code> - Content slides in from the left side of the screen
///   </li>
///   <li>
///     <code>.fromRight</code> - Content slides in from the right side of the screen
///   </li>
/// </ul>
///
/// \param dismissAnimation The animation type to use when dismissing rich media.
/// Available options:
/// <ul>
///   <li>
///     <code>.none</code> - No animation, content disappears immediately (default)
///   </li>
///   <li>
///     <code>.toTop</code> - Content slides out to the top of the screen
///   </li>
///   <li>
///     <code>.toBottom</code> - Content slides out to the bottom of the screen
///   </li>
///   <li>
///     <code>.toLeft</code> - Content slides out to the left side of the screen
///   </li>
///   <li>
///     <code>.toRight</code> - Content slides out to the right side of the screen
///   </li>
/// </ul>
///
+ (void)configureRichMediaWithPosition:(enum PWTVOSRichMediaPosition)position presentAnimation:(enum PWTVOSRichMediaPresentAnimation)presentAnimation dismissAnimation:(enum PWTVOSRichMediaDismissAnimation)dismissAnimation;
/// Controls whether the Close button is displayed on rich media content.
/// By default, a Close button is shown at the bottom of rich media presentations,
/// allowing users to dismiss the content. You can hide this button if you want
/// rich media to only be dismissible through button actions within the content itself.
/// Example:
/// \code
/// // Hide the system Close button
/// Pushwoosh.TVoS.configureCloseButton(false)
///
/// \endcodeNote: If you hide the Close button, ensure your rich media content includes
/// a button with the <code>closeInApp</code> action to allow users to dismiss it.
/// \param show <code>true</code> to show the Close button (default), <code>false</code> to hide it.
///
+ (void)configureCloseButton:(BOOL)show;
/// Sets a handler to receive tags when requested from rich media content.
/// When a user interacts with a getTags button in rich media HTML content,
/// this handler will be called with the tags retrieved from Pushwoosh.
/// This allows you to handle tag data in your application as needed.
/// Example:
/// \code
/// Pushwoosh.TVoS.setRichMediaGetTagsHandler { tags in
///     print("Received tags from rich media: \(tags)")
///     // Handle tags in your application
/// }
///
/// \endcode\param handler A closure that receives tags as a dictionary when getTags is triggered.
/// The dictionary contains tag keys and their values.
///
+ (void)setRichMediaGetTagsHandler:(void (^ _Nonnull)(NSDictionary * _Nonnull))handler;
@end


/// Stub implementation of PWTVoS protocol.
/// This class is used when the PushwooshTVOS module is not linked to the project.
/// All methods provide no-op implementations and print warning messages.
SWIFT_CLASS("_TtC15PushwooshBridge10PWTVoSStub")
@interface PWTVoSStub : NSObject <PWTVoS>
+ (void)setAppCode:(NSString * _Nonnull)appCode;
+ (void)registerForTvPushNotifications;
+ (void)registerForTvPushNotificationsWithToken:(NSData * _Nonnull)token completion:(void (^ _Nullable)(NSError * _Nullable))completion;
+ (void)unregisterForTvPushNotificationsWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
+ (void)handleTvPushToken:(NSData * _Nonnull)deviceToken;
+ (void)handleTvPushRegistrationFailure:(NSError * _Nonnull)error;
+ (void)handleTvPushReceivedWithUserInfo:(NSDictionary * _Nonnull)userInfo completionHandler:(void (^ _Nonnull)(UIBackgroundFetchResult))completionHandler;
+ (BOOL)handleTVOSPushWithUserInfo:(NSDictionary * _Nonnull)userInfo SWIFT_WARN_UNUSED_RESULT;
+ (void)configureRichMediaWithPosition:(enum PWTVOSRichMediaPosition)position presentAnimation:(enum PWTVOSRichMediaPresentAnimation)presentAnimation dismissAnimation:(enum PWTVOSRichMediaDismissAnimation)dismissAnimation;
+ (void)configureCloseButton:(BOOL)show;
+ (void)setRichMediaGetTagsHandler:(void (^ _Nonnull)(NSDictionary * _Nonnull))handler;
+ (Class _Nonnull)tvos SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_PROTOCOL("_TtP15PushwooshBridge6PWVoIP_")
@protocol PWVoIP
/// Initializes VoIP configuration with the specified parameters.
/// Call this method during app initialization before starting any CallKit-related operations.
/// \param supportVideo A Boolean value indicating whether video calls are supported.
///
/// \param ringtoneSound The name of the custom ringtone sound file to be used for incoming calls.
///
/// \param handleTypes The type of call handle to support:
/// (Pass one of the following values)
/// <ul>
///   <li>
///     1 – Generic
///   </li>
///   <li>
///     2 – Phone number
///   </li>
///   <li>
///     3 – Email address
///   </li>
/// </ul>
///
+ (void)initializeVoIP:(BOOL)supportVideo ringtoneSound:(NSString * _Nonnull)ringtoneSound handleTypes:(NSInteger)handleTypes;
/// Sets the VoIP push token for Pushwoosh.
/// This method should be called once you receive the VoIP push token from the system.
/// It registers the device with Pushwoosh to enable receiving VoIP push notifications.
/// important:
/// Make sure to call this method from within the <code>pushRegistry(_:didUpdate:for:)</code> delegate method.
/// <ul>
///   <li>
///     Usage:
///   </li>
/// </ul>
/// \code
/// func pushRegistry(_ registry: PKPushRegistry, didUpdate pushCredentials: PKPushCredentials, for type: PKPushType) {
///     Pushwoosh.VoIP.setVoIPToken(pushCredentials.token)
/// }
///
///
/// \endcode\param token The VoIP push token received from <code>PKPushRegistry</code>.
///
+ (void)setVoIPToken:(NSData * _Nonnull)token;
/// Configures the Pushwoosh VoIP App ID.
/// \param voipAppId A Pushwoosh App ID (format: XXXXX-XXXXX) configured for VoIP push notifications.
///
+ (void)setPushwooshVoIPAppId:(NSString * _Nonnull)voipAppId;
@optional
/// A delegate object that conforms to the <code>PWVoIPCallDelegate</code> protocol.
/// Use this property to set an object that handles VoIP call events such as answering,
/// ending, muting, or playing DTMF tones. The delegate should conform to the
/// <code>PWVoIPCallDelegate</code> protocol and must be assigned before handling any call actions.
/// note:
/// This is an optional static property. Set to <code>nil</code> to remove the delegate.
/// <ul>
///   <li>
///     Usage (Swift):
///   </li>
/// </ul>
/// \code
/// Pushwoosh.VoIP.delegate = self
///
/// \endcodeEnsure that <code>self</code> conforms to <code>PWVoIPCallDelegate</code>.
/// <ul>
///   <li>
///     Usage (Objective-C):
///   </li>
/// </ul>
/// \code
/// [[Pushwoosh VoIP] setDelegate:self];
///
/// \endcodeMake sure <code>self</code> conforms to <code><PWVoIPCallDelegate></code>.
/// Call <code>.delegate = self</code> before <code>initializeVoip()</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id _Nullable delegate;)
+ (id _Nullable)delegate SWIFT_WARN_UNUSED_RESULT;
+ (void)setDelegate:(id _Nullable)newValue;
@end


SWIFT_CLASS("_TtC15PushwooshBridge10PWVoIPStub")
@interface PWVoIPStub : NSObject <PWVoIP>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id _Nullable delegate;)
+ (id _Nullable)delegate SWIFT_WARN_UNUSED_RESULT;
+ (void)setDelegate:(id _Nullable)value;
+ (Class _Nonnull)voip SWIFT_WARN_UNUSED_RESULT;
+ (void)setVoIPToken:(NSData * _Nonnull)token;
+ (void)setPushwooshVoIPAppId:(NSString * _Nonnull)voipAppId;
+ (void)initializeVoIP:(BOOL)supportVideo ringtoneSound:(NSString * _Nonnull)ringtoneSound handleTypes:(NSInteger)handleTypes;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
#ifndef PUSHWOOSHBRIDGE_SWIFT_H
#define PUSHWOOSHBRIDGE_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="PushwooshBridge",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
@class UIColor;
@class UIFont;
@class NSObject;
enum PWForegroundPushStyle : NSInteger;
enum PWForegroundPushHapticFeedback : NSInteger;
enum PWForegroundPushDisappearedAnimation : NSInteger;

/// Protocol for handling custom foreground pushes in Pushwoosh.
/// Allows configuration of appearance, haptic feedback, and tap callbacks for foreground push notifications.
SWIFT_PROTOCOL("_TtP15PushwooshBridge16PWForegroundPush_")
@protocol PWForegroundPush
/// Custom gradient colors for the push background.
/// If set to nil, the default gradient is used.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSArray<UIColor *> * _Nullable gradientColors;)
+ (NSArray<UIColor *> * _Nullable)gradientColors SWIFT_WARN_UNUSED_RESULT;
+ (void)setGradientColors:(NSArray<UIColor *> * _Nullable)newValue;
/// Background color for the push.
/// If nil and <code>gradientColors</code> is not set, the default gradient is used.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIColor * _Nullable backgroundColor;)
+ (UIColor * _Nullable)backgroundColor SWIFT_WARN_UNUSED_RESULT;
+ (void)setBackgroundColor:(UIColor * _Nullable)newValue;
/// Determines whether to use the default push animation when displaying a foreground push.
/// If <code>true</code>, the push notification will animate in with a slide and wave effect.
/// If <code>false</code>, the push will appear instantly without animation.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL usePushAnimation;)
+ (BOOL)usePushAnimation SWIFT_WARN_UNUSED_RESULT;
+ (void)setUsePushAnimation:(BOOL)newValue;
/// Color for the push title text.
/// Defaults to system white if nil.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIColor * _Nullable titlePushColor;)
+ (UIColor * _Nullable)titlePushColor SWIFT_WARN_UNUSED_RESULT;
+ (void)setTitlePushColor:(UIColor * _Nullable)newValue;
/// The font used for the title text in a foreground push notification.
/// Set this property to customize the appearance of the title.
/// If <code>nil</code>, the default bold system font of size 18 will be used.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIFont * _Nullable titlePushFont;)
+ (UIFont * _Nullable)titlePushFont SWIFT_WARN_UNUSED_RESULT;
+ (void)setTitlePushFont:(UIFont * _Nullable)newValue;
/// The font used for the message body text in a foreground push notification.
/// Set this property to customize the appearance of the message text.
/// If <code>nil</code>, the default system font will be used.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIFont * _Nullable messagePushFont;)
+ (UIFont * _Nullable)messagePushFont SWIFT_WARN_UNUSED_RESULT;
+ (void)setMessagePushFont:(UIFont * _Nullable)newValue;
/// Color for the push message text.
/// Defaults to system white if nil.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIColor * _Nullable messagePushColor;)
+ (UIColor * _Nullable)messagePushColor SWIFT_WARN_UNUSED_RESULT;
+ (void)setMessagePushColor:(UIColor * _Nullable)newValue;
/// Enables or disables the Liquid Glass style for foreground push notifications.
/// Set this property to <code>true</code> to use the animated Liquid Glass effect (iOS 26+),
/// or <code>false</code> to use the standard push appearance.
/// Note:
/// <ul>
///   <li>
///     If this flag is enabled but the user’s system version is lower than iOS 26,
///     a regular UIView-based push will be shown instead.
///   </li>
///   <li>
///     If your project is compiled with a Swift version <em>lower than 5.13</em>, the Liquid Glass
///     effect will not be available at all — even on iOS 26. In that case, a blurred
///     <code>UIVisualEffectView</code> (with UIBlurEffect) will be used instead on all devices.
///   </li>
/// </ul>
/// In summary:
/// <ul>
///   <li>
///     Swift 5.13+ + iOS 26 → Liquid Glass
///   </li>
///   <li>
///     Swift 5.13+ + iOS < 26 → Standard UIView
///   </li>
///   <li>
///     Swift < 5.13 → Always blurred view (no Liquid Glass support)
///   </li>
/// </ul>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL useLiquidView;)
+ (BOOL)useLiquidView SWIFT_WARN_UNUSED_RESULT;
+ (void)setUseLiquidView:(BOOL)newValue;
/// Callback triggered when the user taps on the push notification.
/// \param userInfo Dictionary containing push payload data.
///
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) void (^ _Nullable didTapForegroundPush)(NSDictionary * _Nonnull);)
+ (void (^ _Nullable)(NSDictionary * _Nonnull))didTapForegroundPush SWIFT_WARN_UNUSED_RESULT;
+ (void)setDidTapForegroundPush:(void (^ _Nullable)(NSDictionary * _Nonnull))newValue;
/// Configure a foreground push with the specified style, duration, and haptic feedback.
/// Call this method during application initialization to set up the foreground push behavior.
/// \param style Display style of the push.
///
/// \param duration Duration (in seconds) to show the push.
///
/// \param vibration Haptic feedback type for the push.
///
/// \param disappearedPushAnimation The animation to use when the push disappears. Use <code>.balls</code> for a particle-like explosion effect, or <code>.regularPush</code> to mimic the standard upward push disappearance.
///
+ (void)foregroundNotificationWithStyle:(enum PWForegroundPushStyle)style duration:(NSInteger)duration vibration:(enum PWForegroundPushHapticFeedback)vibration disappearedPushAnimation:(enum PWForegroundPushDisappearedAnimation)disappearedPushAnimation;
/// Show a foreground push with the specified payload.
/// \param userInfo Dictionary containing push payload data.
///
+ (void)showForegroundPushWithUserInfo:(NSDictionary * _Nonnull)userInfo;
@end

/// Enum representing the disappearance animation of a foreground push notification.
/// <ul>
///   <li>
///     <code>balls</code>: The push notification explodes into small balls when disappearing.
///   </li>
///   <li>
///     <code>regularPush</code>: The push notification moves upward and disappears, mimicking the standard push behavior.
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, PWForegroundPushDisappearedAnimation, open) {
  PWForegroundPushDisappearedAnimationBalls = 0,
  PWForegroundPushDisappearedAnimationRegularPush = 1,
};

typedef SWIFT_ENUM(NSInteger, PWForegroundPushHapticFeedback, open) {
  PWForegroundPushHapticFeedbackNone = 0,
  PWForegroundPushHapticFeedbackLight = 1,
  PWForegroundPushHapticFeedbackMedium = 2,
  PWForegroundPushHapticFeedbackHeavy = 3,
  PWForegroundPushHapticFeedbackSoft = 4,
  PWForegroundPushHapticFeedbackRigid = 5,
  PWForegroundPushHapticFeedbackNotification = 6,
};


SWIFT_CLASS("_TtC15PushwooshBridge20PWForegroundPushStub")
@interface PWForegroundPushStub : NSObject <PWForegroundPush>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSArray<UIColor *> * _Nullable gradientColors;)
+ (NSArray<UIColor *> * _Nullable)gradientColors SWIFT_WARN_UNUSED_RESULT;
+ (void)setGradientColors:(NSArray<UIColor *> * _Nullable)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIColor * _Nullable backgroundColor;)
+ (UIColor * _Nullable)backgroundColor SWIFT_WARN_UNUSED_RESULT;
+ (void)setBackgroundColor:(UIColor * _Nullable)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL usePushAnimation;)
+ (BOOL)usePushAnimation SWIFT_WARN_UNUSED_RESULT;
+ (void)setUsePushAnimation:(BOOL)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIColor * _Nullable titlePushColor;)
+ (UIColor * _Nullable)titlePushColor SWIFT_WARN_UNUSED_RESULT;
+ (void)setTitlePushColor:(UIColor * _Nullable)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIColor * _Nullable messagePushColor;)
+ (UIColor * _Nullable)messagePushColor SWIFT_WARN_UNUSED_RESULT;
+ (void)setMessagePushColor:(UIColor * _Nullable)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIFont * _Nullable titlePushFont;)
+ (UIFont * _Nullable)titlePushFont SWIFT_WARN_UNUSED_RESULT;
+ (void)setTitlePushFont:(UIFont * _Nullable)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIFont * _Nullable messagePushFont;)
+ (UIFont * _Nullable)messagePushFont SWIFT_WARN_UNUSED_RESULT;
+ (void)setMessagePushFont:(UIFont * _Nullable)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL useLiquidView;)
+ (BOOL)useLiquidView SWIFT_WARN_UNUSED_RESULT;
+ (void)setUseLiquidView:(BOOL)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) void (^ _Nullable didTapForegroundPush)(NSDictionary * _Nonnull);)
+ (void (^ _Nullable)(NSDictionary * _Nonnull))didTapForegroundPush SWIFT_WARN_UNUSED_RESULT;
+ (void)setDidTapForegroundPush:(void (^ _Nullable)(NSDictionary * _Nonnull))value;
+ (void)showForegroundPushWithUserInfo:(NSDictionary * _Nonnull)userInfo;
+ (Class _Nonnull)foregroundPush SWIFT_WARN_UNUSED_RESULT;
+ (void)foregroundNotificationWithStyle:(enum PWForegroundPushStyle)style duration:(NSInteger)duration vibration:(enum PWForegroundPushHapticFeedback)vibration disappearedPushAnimation:(enum PWForegroundPushDisappearedAnimation)disappearedPushAnimation;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, PWForegroundPushStyle, open) {
  PWForegroundPushStyleStyle1 = 0,
};

@class NSString;

SWIFT_PROTOCOL("_TtP15PushwooshBridge16PWLiveActivities_")
@protocol PWLiveActivities
/// Sends push to start live activity token to the server.
/// Call this method when you want to initiate live activity via push notification
/// This method should be called when you want to send the push token to the server in order to initiate a live activity via a push notification. Once the token is sent to the server, it allows you to remotely trigger and manage the live activity through push notifications.
/// Example:
/// \code
/// if #available(iOS 17.2, *) {
///         Task {
///             for await data in Activity<LiveActivityAttributes>.pushToStartTokenUpdates {
///                 let token = data.map { String(format: "%02x", $0) }.joined()
///                 do {
///                     try await Pushwoosh.LiveActivities.sendPush(toStartLiveActivityToken: "token")
///                 } catch {
///                     print("Error sending push to start live activity: \(error)")
///                 }
///            }
///        }
///  }
///
/// \endcode
+ (void)sendPushToStartLiveActivityWithToken:(NSString * _Nonnull)token;
+ (void)sendPushToStartLiveActivityWithToken:(NSString * _Nonnull)token completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Sends live activity token to the server.
/// Call this method when you create a live activity.
/// This method sends the activity token and activity ID to the server when a live activity is started on the user’s device. It handles the asynchronous request to notify the server about the new activity. Ensure that both the token and activity ID are valid before calling this method to avoid potential issues.
/// Example:
/// \code
/// do {
///     let activity = try Activity<PushwooshAppAttributes>.request(
///         attributes: attributes,
///         contentState: contentState,
///         pushType: .token)
///     
///     for await data in activity.pushTokenUpdates {
///         guard let token = data.map { String(format: "%02x", $0) }.joined(separator: "") else {
///             continue
///         }
///         
///         do {
///             try await Pushwoosh.LiveActivities.startLiveActivity(token: "token", activityId: "activityId")
///             return token
///         } catch {
///             print("Failed to start live activity with token \(token): \(error.localizedDescription)")
///             return nil
///         }
///     }
///     return nil
/// } catch {
///     print("Error requesting activity: \(error.localizedDescription)")
///     return nil
/// }
///
/// \endcode@param token Activity token
/// @param activityId Activity ID for updating Live Activities by segments
+ (void)startLiveActivityWithToken:(NSString * _Nonnull)token activityId:(NSString * _Nonnull)activityId;
+ (void)startLiveActivityWithToken:(NSString * _Nonnull)token activityId:(NSString * _Nonnull)activityId completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Call this method when you finish working with the live activity and want to notify the server that the activity has ended.
/// This does <em>not</em> stop or remove the activity from the device itself; it simply informs the server that the activity has been completed.
/// This method should be called when you finish working with the live activity. It sends a request to the server to notify that the live activity has been completed. Typically, this is called when the user has completed the task or interaction that was being tracked by the live activity.
/// The server can then process this information and take appropriate actions based on the completion status of the live activity.
/// Example:
/// \code
/// func end(activity: Activity<PushwooshAppAttributes>) {
///     Task {
///         await activity.end(dismissalPolicy: .immediate)
///         try await Pushwoosh.LiveActivities.stopLiveActivity()
///     }
/// }
///
/// \endcode
+ (void)stopLiveActivity;
+ (void)stopLiveActivityWithCompletion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Call this method when you finish working with the live activity and want to notify the server that the activity has ended.
/// This does <em>not</em> stop or remove the activity from the device itself; it simply informs the server that the activity has been completed.
/// This method should be called when you finish working with the live activity. It sends a request to the server to notify that the live activity has been completed. Typically, this is called when the user has completed the task or interaction that was being tracked by the live activity.
/// The server can then process this information and take appropriate actions based on the completion status of the live activity.
/// The <code>activityId</code> is a unique identifier for the live activity instance. It is used to reference the specific activity that is being completed. This ID should be passed to the server so it can associate the completion notification with the correct live activity.
/// Example:
/// \code
/// func end(activity: Activity<PushwooshAppAttributes>) {
///     Task {
///         await activity.end(dismissalPolicy: .immediate)
///         try await Pushwoosh.LiveActivities.stopLiveActivity(activityId: "activityId")
///     }
/// }
///
/// \endcode
+ (void)stopLiveActivityWithActivityId:(NSString * _Nonnull)activityId;
+ (void)stopLiveActivityWithActivityId:(NSString * _Nonnull)activityId completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
@end


SWIFT_CLASS("_TtC15PushwooshBridge20PWStubLiveActivities")
@interface PWStubLiveActivities : NSObject <PWLiveActivities>
+ (Class _Nonnull)liveActivities SWIFT_WARN_UNUSED_RESULT;
+ (void)sendPushToStartLiveActivityWithToken:(NSString * _Nonnull)token;
+ (void)sendPushToStartLiveActivityWithToken:(NSString * _Nonnull)token completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
+ (void)startLiveActivityWithToken:(NSString * _Nonnull)token activityId:(NSString * _Nonnull)activityId;
+ (void)startLiveActivityWithToken:(NSString * _Nonnull)token activityId:(NSString * _Nonnull)activityId completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
+ (void)stopLiveActivity;
+ (void)stopLiveActivityWithCompletion:(void (^ _Nonnull)(NSError * _Nullable))completion;
+ (void)stopLiveActivityWithActivityId:(NSString * _Nonnull)activityId;
+ (void)stopLiveActivityWithActivityId:(NSString * _Nonnull)activityId completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// Animation types for dismissing rich media content on tvOS.
typedef SWIFT_ENUM(NSInteger, PWTVOSRichMediaDismissAnimation, open) {
/// No animation, content disappears immediately (default)
  PWTVOSRichMediaDismissAnimationNone = 0,
/// Content slides out to the top of the screen
  PWTVOSRichMediaDismissAnimationToTop = 1,
/// Content slides out to the bottom of the screen
  PWTVOSRichMediaDismissAnimationToBottom = 2,
/// Content slides out to the left side of the screen
  PWTVOSRichMediaDismissAnimationToLeft = 3,
/// Content slides out to the right side of the screen
  PWTVOSRichMediaDismissAnimationToRight = 4,
};

/// Position options for displaying rich media content on tvOS.
typedef SWIFT_ENUM(NSInteger, PWTVOSRichMediaPosition, open) {
/// Content positioned at the center of the screen (default)
  PWTVOSRichMediaPositionCenter = 0,
/// Content positioned at the left side of the screen
  PWTVOSRichMediaPositionLeft = 1,
/// Content positioned at the right side of the screen
  PWTVOSRichMediaPositionRight = 2,
/// Content positioned at the top of the screen
  PWTVOSRichMediaPositionTop = 3,
/// Content positioned at the bottom of the screen
  PWTVOSRichMediaPositionBottom = 4,
};

/// Animation types for presenting rich media content on tvOS.
typedef SWIFT_ENUM(NSInteger, PWTVOSRichMediaPresentAnimation, open) {
/// No animation, content appears immediately (default)
  PWTVOSRichMediaPresentAnimationNone = 0,
/// Content slides in from the top of the screen
  PWTVOSRichMediaPresentAnimationFromTop = 1,
/// Content slides in from the bottom of the screen
  PWTVOSRichMediaPresentAnimationFromBottom = 2,
/// Content slides in from the left side of the screen
  PWTVOSRichMediaPresentAnimationFromLeft = 3,
/// Content slides in from the right side of the screen
  PWTVOSRichMediaPresentAnimationFromRight = 4,
};

@class NSData;

/// Protocol for handling tvOS-specific features in Pushwoosh.
/// This protocol provides an interface for tvOS-specific functionality that can be
/// optionally included in the project. If the PushwooshTVOS module is not linked,
/// a stub implementation will be used instead.
SWIFT_PROTOCOL("_TtP15PushwooshBridge6PWTVoS_")
@protocol PWTVoS
/// Sets the Pushwoosh application code for tvOS.
/// This method must be called before registering for push notifications.
/// The app code can be found in your Pushwoosh Control Panel.
/// Example:
/// \code
/// Pushwoosh.TVoS.setAppCode("XXXXX-XXXXX")
///
/// \endcode\param appCode The Pushwoosh application identifier.
///
+ (void)setAppCode:(NSString * _Nonnull)appCode;
/// Registers for tvOS push notifications.
/// This method requests push notification authorization and registers the device
/// for remote notifications on tvOS.
+ (void)registerForTvPushNotifications;
/// Registers the tvOS device for push notifications with the Pushwoosh server.
/// Call this method after receiving a device token from Apple Push Notification service.
/// This method sends the device token to Pushwoosh servers to enable push notifications.
/// Example:
/// \code
/// func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
///     Pushwoosh.TVoS.registerForTvPushNotifications(withToken: deviceToken) { error in
///         if let error = error {
///             print("Failed to register: \(error)")
///         } else {
///             print("Successfully registered for push notifications")
///         }
///     }
/// }
///
/// \endcode\param token The device token received from APNs in <code>application(_:didRegisterForRemoteNotificationsWithDeviceToken:)</code>.
///
/// \param completion Optional completion handler called when registration completes. The handler receives an error parameter if registration fails, or nil on success.
///
+ (void)registerForTvPushNotificationsWithToken:(NSData * _Nonnull)token completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Unregisters the tvOS device from receiving push notifications.
/// This method removes the device registration from Pushwoosh servers.
/// The device will no longer receive push notifications until it registers again.
/// Example:
/// \code
/// Pushwoosh.TVoS.unregisterForTvPushNotifications { error in
///     if let error = error {
///         print("Failed to unregister: \(error)")
///     } else {
///         print("Successfully unregistered from push notifications")
///     }
/// }
///
/// \endcode\param completion Optional completion handler called when unregistration completes. The handler receives an error parameter if unregistration fails, or nil on success.
///
+ (void)unregisterForTvPushNotificationsWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Handles the device token received from tvOS push registration.
/// \param deviceToken The device token data received from APNs.
///
+ (void)handleTvPushToken:(NSData * _Nonnull)deviceToken;
/// Handles push registration failure on tvOS.
/// Call this method from application:didFailToRegisterForRemoteNotificationsWithError:
/// to log and handle registration errors.
/// \param error The error that occurred during registration.
///
+ (void)handleTvPushRegistrationFailure:(NSError * _Nonnull)error;
/// Handles incoming push notification on tvOS.
/// Call this method from application:didReceiveRemoteNotification:fetchCompletionHandler:
/// to process incoming push notifications.
/// \param userInfo Dictionary containing push payload data.
///
/// \param completionHandler Completion handler to call when processing is complete.
///
+ (void)handleTvPushReceivedWithUserInfo:(NSDictionary * _Nonnull)userInfo completionHandler:(void (^ _Nonnull)(UIBackgroundFetchResult))completionHandler;
/// Handles incoming push notifications with rich media content for tvOS.
/// Call this method to process push notifications that may contain rich media content.
/// If the notification contains rich media, it will be displayed automatically.
/// Example:
/// \code
/// func application(_ application: UIApplication,
///                  didReceiveRemoteNotification userInfo: [AnyHashable: Any],
///                  fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
///     if Pushwoosh.TVoS.handleTVOSPush(userInfo: userInfo) {
///         completionHandler(.newData)
///     } else {
///         completionHandler(.noData)
///     }
/// }
///
/// \endcode\param userInfo The push notification payload received from APNs.
///
///
/// returns:
/// <code>true</code> if the notification contains rich media and was handled, <code>false</code> otherwise.
+ (BOOL)handleTVOSPushWithUserInfo:(NSDictionary * _Nonnull)userInfo SWIFT_WARN_UNUSED_RESULT;
/// Configures rich media presentation, positioning, and dismissal animations for tvOS.
/// This method allows you to customize how rich media content appears, where it’s positioned,
/// and how it disappears on screen. You can choose from different animation directions,
/// screen positions, or disable animation entirely.
/// Example:
/// \code
/// // Configure rich media to appear on the left, slide in from bottom and slide out to left
/// Pushwoosh.TVoS.configureRichMediaWith(position: .left, presentAnimation: .fromBottom, dismissAnimation: .toLeft)
///
/// // Only configure position and present animation (dismiss will use .none)
/// Pushwoosh.TVoS.configureRichMediaWith(position: .right, presentAnimation: .fromTop, dismissAnimation: .none)
///
/// \endcodeNote: This configuration applies to all subsequent rich media presentations until changed.
/// \param position The screen position where rich media content will be displayed.
/// Available options:
/// <ul>
///   <li>
///     <code>.center</code> - Content positioned at the center of the screen (default)
///   </li>
///   <li>
///     <code>.left</code> - Content positioned at the left side of the screen
///   </li>
///   <li>
///     <code>.right</code> - Content positioned at the right side of the screen
///   </li>
///   <li>
///     <code>.top</code> - Content positioned at the top of the screen
///   </li>
///   <li>
///     <code>.bottom</code> - Content positioned at the bottom of the screen
///   </li>
/// </ul>
///
/// \param presentAnimation The animation type to use when presenting rich media.
/// Available options:
/// <ul>
///   <li>
///     <code>.none</code> - No animation, content appears immediately (default)
///   </li>
///   <li>
///     <code>.fromTop</code> - Content slides in from the top of the screen
///   </li>
///   <li>
///     <code>.fromBottom</code> - Content slides in from the bottom of the screen
///   </li>
///   <li>
///     <code>.fromLeft</code> - Content slides in from the left side of the screen
///   </li>
///   <li>
///     <code>.fromRight</code> - Content slides in from the right side of the screen
///   </li>
/// </ul>
///
/// \param dismissAnimation The animation type to use when dismissing rich media.
/// Available options:
/// <ul>
///   <li>
///     <code>.none</code> - No animation, content disappears immediately (default)
///   </li>
///   <li>
///     <code>.toTop</code> - Content slides out to the top of the screen
///   </li>
///   <li>
///     <code>.toBottom</code> - Content slides out to the bottom of the screen
///   </li>
///   <li>
///     <code>.toLeft</code> - Content slides out to the left side of the screen
///   </li>
///   <li>
///     <code>.toRight</code> - Content slides out to the right side of the screen
///   </li>
/// </ul>
///
+ (void)configureRichMediaWithPosition:(enum PWTVOSRichMediaPosition)position presentAnimation:(enum PWTVOSRichMediaPresentAnimation)presentAnimation dismissAnimation:(enum PWTVOSRichMediaDismissAnimation)dismissAnimation;
/// Controls whether the Close button is displayed on rich media content.
/// By default, a Close button is shown at the bottom of rich media presentations,
/// allowing users to dismiss the content. You can hide this button if you want
/// rich media to only be dismissible through button actions within the content itself.
/// Example:
/// \code
/// // Hide the system Close button
/// Pushwoosh.TVoS.configureCloseButton(false)
///
/// \endcodeNote: If you hide the Close button, ensure your rich media content includes
/// a button with the <code>closeInApp</code> action to allow users to dismiss it.
/// \param show <code>true</code> to show the Close button (default), <code>false</code> to hide it.
///
+ (void)configureCloseButton:(BOOL)show;
/// Sets a handler to receive tags when requested from rich media content.
/// When a user interacts with a getTags button in rich media HTML content,
/// this handler will be called with the tags retrieved from Pushwoosh.
/// This allows you to handle tag data in your application as needed.
/// Example:
/// \code
/// Pushwoosh.TVoS.setRichMediaGetTagsHandler { tags in
///     print("Received tags from rich media: \(tags)")
///     // Handle tags in your application
/// }
///
/// \endcode\param handler A closure that receives tags as a dictionary when getTags is triggered.
/// The dictionary contains tag keys and their values.
///
+ (void)setRichMediaGetTagsHandler:(void (^ _Nonnull)(NSDictionary * _Nonnull))handler;
@end


/// Stub implementation of PWTVoS protocol.
/// This class is used when the PushwooshTVOS module is not linked to the project.
/// All methods provide no-op implementations and print warning messages.
SWIFT_CLASS("_TtC15PushwooshBridge10PWTVoSStub")
@interface PWTVoSStub : NSObject <PWTVoS>
+ (void)setAppCode:(NSString * _Nonnull)appCode;
+ (void)registerForTvPushNotifications;
+ (void)registerForTvPushNotificationsWithToken:(NSData * _Nonnull)token completion:(void (^ _Nullable)(NSError * _Nullable))completion;
+ (void)unregisterForTvPushNotificationsWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
+ (void)handleTvPushToken:(NSData * _Nonnull)deviceToken;
+ (void)handleTvPushRegistrationFailure:(NSError * _Nonnull)error;
+ (void)handleTvPushReceivedWithUserInfo:(NSDictionary * _Nonnull)userInfo completionHandler:(void (^ _Nonnull)(UIBackgroundFetchResult))completionHandler;
+ (BOOL)handleTVOSPushWithUserInfo:(NSDictionary * _Nonnull)userInfo SWIFT_WARN_UNUSED_RESULT;
+ (void)configureRichMediaWithPosition:(enum PWTVOSRichMediaPosition)position presentAnimation:(enum PWTVOSRichMediaPresentAnimation)presentAnimation dismissAnimation:(enum PWTVOSRichMediaDismissAnimation)dismissAnimation;
+ (void)configureCloseButton:(BOOL)show;
+ (void)setRichMediaGetTagsHandler:(void (^ _Nonnull)(NSDictionary * _Nonnull))handler;
+ (Class _Nonnull)tvos SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_PROTOCOL("_TtP15PushwooshBridge6PWVoIP_")
@protocol PWVoIP
/// Initializes VoIP configuration with the specified parameters.
/// Call this method during app initialization before starting any CallKit-related operations.
/// \param supportVideo A Boolean value indicating whether video calls are supported.
///
/// \param ringtoneSound The name of the custom ringtone sound file to be used for incoming calls.
///
/// \param handleTypes The type of call handle to support:
/// (Pass one of the following values)
/// <ul>
///   <li>
///     1 – Generic
///   </li>
///   <li>
///     2 – Phone number
///   </li>
///   <li>
///     3 – Email address
///   </li>
/// </ul>
///
+ (void)initializeVoIP:(BOOL)supportVideo ringtoneSound:(NSString * _Nonnull)ringtoneSound handleTypes:(NSInteger)handleTypes;
/// Sets the VoIP push token for Pushwoosh.
/// This method should be called once you receive the VoIP push token from the system.
/// It registers the device with Pushwoosh to enable receiving VoIP push notifications.
/// important:
/// Make sure to call this method from within the <code>pushRegistry(_:didUpdate:for:)</code> delegate method.
/// <ul>
///   <li>
///     Usage:
///   </li>
/// </ul>
/// \code
/// func pushRegistry(_ registry: PKPushRegistry, didUpdate pushCredentials: PKPushCredentials, for type: PKPushType) {
///     Pushwoosh.VoIP.setVoIPToken(pushCredentials.token)
/// }
///
///
/// \endcode\param token The VoIP push token received from <code>PKPushRegistry</code>.
///
+ (void)setVoIPToken:(NSData * _Nonnull)token;
/// Configures the Pushwoosh VoIP App ID.
/// \param voipAppId A Pushwoosh App ID (format: XXXXX-XXXXX) configured for VoIP push notifications.
///
+ (void)setPushwooshVoIPAppId:(NSString * _Nonnull)voipAppId;
@optional
/// A delegate object that conforms to the <code>PWVoIPCallDelegate</code> protocol.
/// Use this property to set an object that handles VoIP call events such as answering,
/// ending, muting, or playing DTMF tones. The delegate should conform to the
/// <code>PWVoIPCallDelegate</code> protocol and must be assigned before handling any call actions.
/// note:
/// This is an optional static property. Set to <code>nil</code> to remove the delegate.
/// <ul>
///   <li>
///     Usage (Swift):
///   </li>
/// </ul>
/// \code
/// Pushwoosh.VoIP.delegate = self
///
/// \endcodeEnsure that <code>self</code> conforms to <code>PWVoIPCallDelegate</code>.
/// <ul>
///   <li>
///     Usage (Objective-C):
///   </li>
/// </ul>
/// \code
/// [[Pushwoosh VoIP] setDelegate:self];
///
/// \endcodeMake sure <code>self</code> conforms to <code><PWVoIPCallDelegate></code>.
/// Call <code>.delegate = self</code> before <code>initializeVoip()</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id _Nullable delegate;)
+ (id _Nullable)delegate SWIFT_WARN_UNUSED_RESULT;
+ (void)setDelegate:(id _Nullable)newValue;
@end


SWIFT_CLASS("_TtC15PushwooshBridge10PWVoIPStub")
@interface PWVoIPStub : NSObject <PWVoIP>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id _Nullable delegate;)
+ (id _Nullable)delegate SWIFT_WARN_UNUSED_RESULT;
+ (void)setDelegate:(id _Nullable)value;
+ (Class _Nonnull)voip SWIFT_WARN_UNUSED_RESULT;
+ (void)setVoIPToken:(NSData * _Nonnull)token;
+ (void)setPushwooshVoIPAppId:(NSString * _Nonnull)voipAppId;
+ (void)initializeVoIP:(BOOL)supportVideo ringtoneSound:(NSString * _Nonnull)ringtoneSound handleTypes:(NSInteger)handleTypes;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
