// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pushwoosh/device.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Pushwoosh_DeviceApi_V2_LoadDevicesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwids: [String] = []

  public var pushTokens: [String] = []

  public var users: [String] = []

  public var application: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_LoadDevicesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var devices: [Pushwoosh_DeviceApi_V2_Device] = []

  /// only available when loading by user
  public var userTags: [Pushwoosh_DeviceApi_V2_Tag] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_TagList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tags: [Pushwoosh_DeviceApi_V2_Tag] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_Device: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwid: String = String()

  public var platform: UInt32 = 0

  public var pushTokens: Dictionary<String,String> = [:]

  public var deviceTags: [Pushwoosh_DeviceApi_V2_Tag] = []

  public var appTags: Dictionary<String,Pushwoosh_DeviceApi_V2_TagList> = [:]

  public var users: Dictionary<String,Pushwoosh_DeviceApi_V2_User> = [:]

  public var badges: Dictionary<String,Int32> = [:]

  public var attributes: Dictionary<String,String> = [:]

  public var fcmKeys: Dictionary<String,Pushwoosh_DeviceApi_V2_FCMKey> = [:]

  public var webKeys: Dictionary<String,Pushwoosh_DeviceApi_V2_WebKey> = [:]

  public var unsubscribed: Bool = false

  public var location: Pushwoosh_DeviceApi_V2_Location {
    get {return _location ?? Pushwoosh_DeviceApi_V2_Location()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {self._location = nil}

  public var voipPushTokens: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _location: Pushwoosh_DeviceApi_V2_Location? = nil
}

public struct Pushwoosh_DeviceApi_V2_FCMKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String = String()

  public var pushSet: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_Location: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lat: Double = 0

  public var lon: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_WebKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var publicKey: String = String()

  public var authToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_StringList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var values: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_Tag: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var value: Pushwoosh_DeviceApi_V2_Tag.OneOf_Value? = nil

  public var integer: Int32 {
    get {
      if case .integer(let v)? = value {return v}
      return 0
    }
    set {value = .integer(newValue)}
  }

  public var string: String {
    get {
      if case .string(let v)? = value {return v}
      return String()
    }
    set {value = .string(newValue)}
  }

  public var list: Pushwoosh_DeviceApi_V2_StringList {
    get {
      if case .list(let v)? = value {return v}
      return Pushwoosh_DeviceApi_V2_StringList()
    }
    set {value = .list(newValue)}
  }

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .date(let v)? = value {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {value = .date(newValue)}
  }

  public var boolean: Bool {
    get {
      if case .boolean(let v)? = value {return v}
      return false
    }
    set {value = .boolean(newValue)}
  }

  public var price: String {
    get {
      if case .price(let v)? = value {return v}
      return String()
    }
    set {value = .price(newValue)}
  }

  public var version: String {
    get {
      if case .version(let v)? = value {return v}
      return String()
    }
    set {value = .version(newValue)}
  }

  public var timezone: Int32 {
    get {
      if case .timezone(let v)? = value {return v}
      return 0
    }
    set {value = .timezone(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable, Sendable {
    case integer(Int32)
    case string(String)
    case list(Pushwoosh_DeviceApi_V2_StringList)
    case date(SwiftProtobuf.Google_Protobuf_Timestamp)
    case boolean(Bool)
    case price(String)
    case version(String)
    case timezone(Int32)

  }

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_User: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pushwoosh.device_api.v2"

extension Pushwoosh_DeviceApi_V2_LoadDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadDevicesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwids\0\u{3}push_tokens\0\u{1}users\0\u{1}application\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.hwids) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.pushTokens) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.users) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.application) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hwids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.hwids, fieldNumber: 1)
    }
    if !self.pushTokens.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pushTokens, fieldNumber: 2)
    }
    if !self.users.isEmpty {
      try visitor.visitRepeatedStringField(value: self.users, fieldNumber: 3)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_LoadDevicesRequest, rhs: Pushwoosh_DeviceApi_V2_LoadDevicesRequest) -> Bool {
    if lhs.hwids != rhs.hwids {return false}
    if lhs.pushTokens != rhs.pushTokens {return false}
    if lhs.users != rhs.users {return false}
    if lhs.application != rhs.application {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_LoadDevicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadDevicesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}devices\0\u{3}user_tags\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.userTags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    if !self.userTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userTags, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_LoadDevicesResponse, rhs: Pushwoosh_DeviceApi_V2_LoadDevicesResponse) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.userTags != rhs.userTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_TagList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TagList"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}tags\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tags, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_TagList, rhs: Pushwoosh_DeviceApi_V2_TagList) -> Bool {
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Device"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}platform\0\u{3}push_tokens\0\u{3}device_tags\0\u{3}app_tags\0\u{1}users\0\u{1}badges\0\u{1}attributes\0\u{3}fcm_keys\0\u{3}web_keys\0\u{1}unsubscribed\0\u{1}location\0\u{3}voip_push_tokens\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.platform) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.pushTokens) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.deviceTags) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pushwoosh_DeviceApi_V2_TagList>.self, value: &self.appTags) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pushwoosh_DeviceApi_V2_User>.self, value: &self.users) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.badges) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attributes) }()
      case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pushwoosh_DeviceApi_V2_FCMKey>.self, value: &self.fcmKeys) }()
      case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pushwoosh_DeviceApi_V2_WebKey>.self, value: &self.webKeys) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.unsubscribed) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 13: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.voipPushTokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if self.platform != 0 {
      try visitor.visitSingularUInt32Field(value: self.platform, fieldNumber: 2)
    }
    if !self.pushTokens.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.pushTokens, fieldNumber: 3)
    }
    if !self.deviceTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deviceTags, fieldNumber: 4)
    }
    if !self.appTags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pushwoosh_DeviceApi_V2_TagList>.self, value: self.appTags, fieldNumber: 5)
    }
    if !self.users.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pushwoosh_DeviceApi_V2_User>.self, value: self.users, fieldNumber: 6)
    }
    if !self.badges.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.badges, fieldNumber: 7)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attributes, fieldNumber: 8)
    }
    if !self.fcmKeys.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pushwoosh_DeviceApi_V2_FCMKey>.self, value: self.fcmKeys, fieldNumber: 9)
    }
    if !self.webKeys.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pushwoosh_DeviceApi_V2_WebKey>.self, value: self.webKeys, fieldNumber: 10)
    }
    if self.unsubscribed != false {
      try visitor.visitSingularBoolField(value: self.unsubscribed, fieldNumber: 11)
    }
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    if !self.voipPushTokens.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.voipPushTokens, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_Device, rhs: Pushwoosh_DeviceApi_V2_Device) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.pushTokens != rhs.pushTokens {return false}
    if lhs.deviceTags != rhs.deviceTags {return false}
    if lhs.appTags != rhs.appTags {return false}
    if lhs.users != rhs.users {return false}
    if lhs.badges != rhs.badges {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.fcmKeys != rhs.fcmKeys {return false}
    if lhs.webKeys != rhs.webKeys {return false}
    if lhs.unsubscribed != rhs.unsubscribed {return false}
    if lhs._location != rhs._location {return false}
    if lhs.voipPushTokens != rhs.voipPushTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_FCMKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FCMKey"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}token\0\u{3}push_set\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pushSet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.pushSet.isEmpty {
      try visitor.visitSingularStringField(value: self.pushSet, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_FCMKey, rhs: Pushwoosh_DeviceApi_V2_FCMKey) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.pushSet != rhs.pushSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Location"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}lat\0\u{1}lon\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.lat) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.lon) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lat.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lat, fieldNumber: 1)
    }
    if self.lon.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lon, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_Location, rhs: Pushwoosh_DeviceApi_V2_Location) -> Bool {
    if lhs.lat != rhs.lat {return false}
    if lhs.lon != rhs.lon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_WebKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WebKey"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}public_key\0\u{3}auth_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.authToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.authToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_WebKey, rhs: Pushwoosh_DeviceApi_V2_WebKey) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.authToken != rhs.authToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_StringList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StringList"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}values\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_StringList, rhs: Pushwoosh_DeviceApi_V2_StringList) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_Tag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Tag"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}integer\0\u{1}string\0\u{1}list\0\u{1}date\0\u{1}boolean\0\u{1}price\0\u{1}version\0\u{1}timezone\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .integer(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .string(v)
        }
      }()
      case 4: try {
        var v: Pushwoosh_DeviceApi_V2_StringList?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .list(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .list(v)
        }
      }()
      case 5: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .date(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .date(v)
        }
      }()
      case 6: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .boolean(v)
        }
      }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .price(v)
        }
      }()
      case 8: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .version(v)
        }
      }()
      case 9: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .timezone(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.value {
    case .integer?: try {
      guard case .integer(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }()
    case .string?: try {
      guard case .string(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .list?: try {
      guard case .list(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .date?: try {
      guard case .date(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .boolean?: try {
      guard case .boolean(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }()
    case .price?: try {
      guard case .price(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }()
    case .version?: try {
      guard case .version(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }()
    case .timezone?: try {
      guard case .timezone(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_Tag, rhs: Pushwoosh_DeviceApi_V2_Tag) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".User"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_User, rhs: Pushwoosh_DeviceApi_V2_User) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
