// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: device_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Pushwoosh_DeviceApi_V2_ApplicationOpenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// device hwid
  public var hwid: String = String()

  public var application: String = String()

  /// device type (1 = iOS, 3 = Android, etc.)
  public var platform: UInt32 = 0

  public var language: String = String()

  public var appVersion: String = String()

  public var deviceModel: String = String()

  public var osVersion: String = String()

  /// v in payload
  public var sdkVersion: String = String()

  /// true if not provided
  public var pushAlertsEnabled: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _pushAlertsEnabled ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_pushAlertsEnabled = newValue}
  }
  /// Returns true if `pushAlertsEnabled` has been explicitly set.
  public var hasPushAlertsEnabled: Bool {return self._pushAlertsEnabled != nil}
  /// Clears the value of `pushAlertsEnabled`. Subsequent reads from it will return its default value.
  public mutating func clearPushAlertsEnabled() {self._pushAlertsEnabled = nil}

  /// UTC if not provided
  public var timezone: String = String()

  public var timeSensitiveNotifications: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _timeSensitiveNotifications ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_timeSensitiveNotifications = newValue}
  }
  /// Returns true if `timeSensitiveNotifications` has been explicitly set.
  public var hasTimeSensitiveNotifications: Bool {return self._timeSensitiveNotifications != nil}
  /// Clears the value of `timeSensitiveNotifications`. Subsequent reads from it will return its default value.
  public mutating func clearTimeSensitiveNotifications() {self._timeSensitiveNotifications = nil}

  public var scheduledSummary: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _scheduledSummary ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_scheduledSummary = newValue}
  }
  /// Returns true if `scheduledSummary` has been explicitly set.
  public var hasScheduledSummary: Bool {return self._scheduledSummary != nil}
  /// Clears the value of `scheduledSummary`. Subsequent reads from it will return its default value.
  public mutating func clearScheduledSummary() {self._scheduledSummary = nil}

  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pushAlertsEnabled: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _timeSensitiveNotifications: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _scheduledSummary: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

public struct Pushwoosh_DeviceApi_V2_ApplicationOpenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// in-app messages to preload on the device
  public var requiredInapps: Dictionary<String,Pushwoosh_DeviceApi_V2_ApplicationOpenResponse.RequiredInApp> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct RequiredInApp: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: String = String()

    public var updated: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_SetBadgeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwid: String = String()

  public var application: String = String()

  public var badge: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_SetBadgeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_PushStatRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwid: String = String()

  public var application: String = String()

  public var hash: String = String()

  public var platform: UInt32 = 0

  public var userID: String = String()

  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Pushwoosh_DeviceApi_V2_PushStatResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_MessageDeliveryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwid: String = String()

  public var application: String = String()

  public var hash: String = String()

  public var platform: UInt32 = 0

  public var userID: String = String()

  public var messageID: UInt64 = 0

  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Pushwoosh_DeviceApi_V2_MessageDeliveryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_SetTagsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwid: String = String()

  public var application: String = String()

  public var userID: String = String()

  public var platform: UInt32 = 0

  public var tags: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _tags ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_tags = newValue}
  }
  /// Returns true if `tags` has been explicitly set.
  public var hasTags: Bool {return self._tags != nil}
  /// Clears the value of `tags`. Subsequent reads from it will return its default value.
  public mutating func clearTags() {self._tags = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tags: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Pushwoosh_DeviceApi_V2_SetTagsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var application: String = String()

  public var email: String = String()

  public var smsPhoneNumber: String = String()

  public var whatsappPhoneNumber: String = String()

  public var kakaoPhoneNumber: String = String()

  public var lineToken: String = String()

  public var telegramUserID: String = String()

  public var language: String = String()

  /// UTC if not provided
  public var timezone: String = String()

  public var city: String = String()

  public var country: String = String()

  public var state: String = String()

  public var tags: Dictionary<String,Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.TagValue> = [:]

  public var pushDevices: [Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct TagValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var operation: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.TagValue.Operation = .set

    /// will be auto converted to proper tag value (or type will be auto detected for new tags)
    public var value: String = String()

    /// must be present for list operations
    public var values: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Operation: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case set // = 0
      case append // = 1
      case remove // = 2
      case increment // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .set
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .set
        case 1: self = .append
        case 2: self = .remove
        case 3: self = .increment
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .set: return 0
        case .append: return 1
        case .remove: return 2
        case .increment: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.TagValue.Operation] = [
        .set,
        .append,
        .remove,
        .increment,
      ]

    }

    public init() {}
  }

  public struct PushDevice: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var hwid: String = String()

    public var platform: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.Platform = .unspecified

    public var pushToken: String = String()

    public var appVersion: String = String()

    public var osVersion: String = String()

    public var sdkVersion: String = String()

    public var location: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.Location {
      get {return _location ?? Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.Location()}
      set {_location = newValue}
    }
    /// Returns true if `location` has been explicitly set.
    public var hasLocation: Bool {return self._location != nil}
    /// Clears the value of `location`. Subsequent reads from it will return its default value.
    public mutating func clearLocation() {self._location = nil}

    public var platformData: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.OneOf_PlatformData? = nil

    public var push: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.PushPlatformData {
      get {
        if case .push(let v)? = platformData {return v}
        return Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.PushPlatformData()
      }
      set {platformData = .push(newValue)}
    }

    public var webPush: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.WebPushPlatformData {
      get {
        if case .webPush(let v)? = platformData {return v}
        return Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.WebPushPlatformData()
      }
      set {platformData = .webPush(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_PlatformData: Equatable, Sendable {
      case push(Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.PushPlatformData)
      case webPush(Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.WebPushPlatformData)

    }

    public enum Platform: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case unspecified // = 0
      case ios // = 1
      case android // = 3
      case osx // = 7
      case windows // = 8
      case amazon // = 9
      case safari // = 10
      case chrome // = 11
      case firefox // = 12
      case huaweiAndroid // = 17
      case web // = 20
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .ios
        case 3: self = .android
        case 7: self = .osx
        case 8: self = .windows
        case 9: self = .amazon
        case 10: self = .safari
        case 11: self = .chrome
        case 12: self = .firefox
        case 17: self = .huaweiAndroid
        case 20: self = .web
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .ios: return 1
        case .android: return 3
        case .osx: return 7
        case .windows: return 8
        case .amazon: return 9
        case .safari: return 10
        case .chrome: return 11
        case .firefox: return 12
        case .huaweiAndroid: return 17
        case .web: return 20
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.Platform] = [
        .unspecified,
        .ios,
        .android,
        .osx,
        .windows,
        .amazon,
        .safari,
        .chrome,
        .firefox,
        .huaweiAndroid,
        .web,
      ]

    }

    public struct Location: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var lat: Double = 0

      public var lon: Double = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct PushPlatformData: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// true if not provided
      public var pushAlertsEnabled: SwiftProtobuf.Google_Protobuf_BoolValue {
        get {return _pushAlertsEnabled ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
        set {_pushAlertsEnabled = newValue}
      }
      /// Returns true if `pushAlertsEnabled` has been explicitly set.
      public var hasPushAlertsEnabled: Bool {return self._pushAlertsEnabled != nil}
      /// Clears the value of `pushAlertsEnabled`. Subsequent reads from it will return its default value.
      public mutating func clearPushAlertsEnabled() {self._pushAlertsEnabled = nil}

      public var deviceModel: String = String()

      public var applicationSounds: [String] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _pushAlertsEnabled: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    }

    public struct WebPushPlatformData: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var publicKey: String = String()

      public var authToken: String = String()

      public var browser: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _location: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.Location? = nil
  }

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_MultiRegisterDeviceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_GetPlatformConfigurationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var application: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ios: Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS {
    get {return _ios ?? Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS()}
    set {_ios = newValue}
  }
  /// Returns true if `ios` has been explicitly set.
  public var hasIos: Bool {return self._ios != nil}
  /// Clears the value of `ios`. Subsequent reads from it will return its default value.
  public mutating func clearIos() {self._ios = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct PlatformParamIOS: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var categories: [Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS.Category] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Category: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var categoryID: Int32 = 0

      public var buttons: [Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS.Category.Button] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum ButtonType: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int
        case `default` // = 0
        case destructive // = 1
        case UNRECOGNIZED(Int)

        public init() {
          self = .default
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .default
          case 1: self = .destructive
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .default: return 0
          case .destructive: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS.Category.ButtonType] = [
          .default,
          .destructive,
        ]

      }

      public enum StartApplication: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int
        case startAppBackground // = 0
        case startAppForeground // = 1
        case UNRECOGNIZED(Int)

        public init() {
          self = .startAppBackground
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .startAppBackground
          case 1: self = .startAppForeground
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .startAppBackground: return 0
          case .startAppForeground: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS.Category.StartApplication] = [
          .startAppBackground,
          .startAppForeground,
        ]

      }

      public struct Button: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var label: String = String()

        public var type: Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS.Category.ButtonType = .default

        public var startApplication: Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS.Category.StartApplication = .startAppBackground

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _ios: Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS? = nil
}

public struct Pushwoosh_DeviceApi_V2_RegisterDeviceRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwid: String {
    get {return _storage._hwid}
    set {_uniqueStorage()._hwid = newValue}
  }

  public var application: String {
    get {return _storage._application}
    set {_uniqueStorage()._application = newValue}
  }

  public var platform: UInt32 {
    get {return _storage._platform}
    set {_uniqueStorage()._platform = newValue}
  }

  public var pushToken: String {
    get {return _storage._pushToken}
    set {_uniqueStorage()._pushToken = newValue}
  }

  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  public var language: String {
    get {return _storage._language}
    set {_uniqueStorage()._language = newValue}
  }

  public var appVersion: String {
    get {return _storage._appVersion}
    set {_uniqueStorage()._appVersion = newValue}
  }

  public var deviceModel: String {
    get {return _storage._deviceModel}
    set {_uniqueStorage()._deviceModel = newValue}
  }

  public var osVersion: String {
    get {return _storage._osVersion}
    set {_uniqueStorage()._osVersion = newValue}
  }

  public var sdkVersion: String {
    get {return _storage._sdkVersion}
    set {_uniqueStorage()._sdkVersion = newValue}
  }

  public var pushAlertsEnabled: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._pushAlertsEnabled ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._pushAlertsEnabled = newValue}
  }
  /// Returns true if `pushAlertsEnabled` has been explicitly set.
  public var hasPushAlertsEnabled: Bool {return _storage._pushAlertsEnabled != nil}
  /// Clears the value of `pushAlertsEnabled`. Subsequent reads from it will return its default value.
  public mutating func clearPushAlertsEnabled() {_uniqueStorage()._pushAlertsEnabled = nil}

  public var timezone: String {
    get {return _storage._timezone}
    set {_uniqueStorage()._timezone = newValue}
  }

  public var timeSensitiveNotifications: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._timeSensitiveNotifications ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._timeSensitiveNotifications = newValue}
  }
  /// Returns true if `timeSensitiveNotifications` has been explicitly set.
  public var hasTimeSensitiveNotifications: Bool {return _storage._timeSensitiveNotifications != nil}
  /// Clears the value of `timeSensitiveNotifications`. Subsequent reads from it will return its default value.
  public mutating func clearTimeSensitiveNotifications() {_uniqueStorage()._timeSensitiveNotifications = nil}

  public var scheduledSummary: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._scheduledSummary ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._scheduledSummary = newValue}
  }
  /// Returns true if `scheduledSummary` has been explicitly set.
  public var hasScheduledSummary: Bool {return _storage._scheduledSummary != nil}
  /// Clears the value of `scheduledSummary`. Subsequent reads from it will return its default value.
  public mutating func clearScheduledSummary() {_uniqueStorage()._scheduledSummary = nil}

  /// Application WebKeys
  public var publicKey: String {
    get {return _storage._publicKey}
    set {_uniqueStorage()._publicKey = newValue}
  }

  public var authToken: String {
    get {return _storage._authToken}
    set {_uniqueStorage()._authToken = newValue}
  }

  /// Application FcmKeys
  public var fcmToken: String {
    get {return _storage._fcmToken}
    set {_uniqueStorage()._fcmToken = newValue}
  }

  public var fcmPushSet: String {
    get {return _storage._fcmPushSet}
    set {_uniqueStorage()._fcmPushSet = newValue}
  }

  /// sounds for push notification from app bundle
  public var sounds: [String] {
    get {return _storage._sounds}
    set {_uniqueStorage()._sounds = newValue}
  }

  public var tags: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._tags ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._tags = newValue}
  }
  /// Returns true if `tags` has been explicitly set.
  public var hasTags: Bool {return _storage._tags != nil}
  /// Clears the value of `tags`. Subsequent reads from it will return its default value.
  public mutating func clearTags() {_uniqueStorage()._tags = nil}

  public var voipPushToken: String {
    get {return _storage._voipPushToken}
    set {_uniqueStorage()._voipPushToken = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Pushwoosh_DeviceApi_V2_RegisterDeviceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var iosCategories: [Pushwoosh_DeviceApi_V2_RegisterDeviceResponse.IOSCategory] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct IOSCategory: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var categoryID: Int32 = 0

    public var buttons: [Pushwoosh_DeviceApi_V2_RegisterDeviceResponse.IOSCategory.Button] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Button: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var id: String = String()

      public var label: String = String()

      /// destructive or not
      public var type: Int32 = 0

      public var startApplication: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_UnregisterDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwid: String = String()

  public var application: String = String()

  public var hash: String = String()

  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Pushwoosh_DeviceApi_V2_UnregisterDeviceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_DeleteDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwid: String = String()

  public var application: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_DeleteDeviceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_DeleteUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var application: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_DeleteUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_GetInAppsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var application: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_GetInAppsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inApps: [Pushwoosh_DeviceApi_V2_GetInAppsResponse.InApp] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct InApp: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var url: String = String()

    public var code: String = String()

    public var layout: String = String()

    public var updated: Int32 = 0

    public var closeButtonType: Int32 = 0

    public var hash: String = String()

    public var required: Bool = false

    public var priority: Int32 = 0

    public var businessCase: String = String()

    public var gdpr: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_SetAttributesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwid: String = String()

  public var application: String = String()

  public var key: String = String()

  public var encryptedData: String = String()

  public var attributes: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _attributes ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_attributes = newValue}
  }
  /// Returns true if `attributes` has been explicitly set.
  public var hasAttributes: Bool {return self._attributes != nil}
  /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
  public mutating func clearAttributes() {self._attributes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _attributes: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Pushwoosh_DeviceApi_V2_SetAttributesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_CheckDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwid: String = String()

  public var application: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_CheckDeviceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exist: Bool = false

  public var pushTokenExist: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_RegisterUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwid: String = String()

  public var application: String = String()

  public var userID: String = String()

  public var platform: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_RegisterUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_GetTagsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwid: String = String()

  public var application: String = String()

  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_GetTagsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _result ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Pushwoosh_DeviceApi_V2_EmailLinkClickRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// email
  public var hwid: String = String()

  public var application: String = String()

  public var redirectLink: String = String()

  /// don't know why we need this
  public var originalLink: String = String()

  /// don't know why we need this
  public var originalTitle: String = String()

  public var templateCode: String = String()

  public var hash: String = String()

  public var pointUuid: String = String()

  public var ip: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_EmailLinkClickResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_GetUnregisteredDevicesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: String = String()

  public var application: String = String()

  /// format YYYY-MM-DD
  public var dateFrom: String = String()

  public var dateTo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_GetUnregisteredDevicesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_SetActivityTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwid: String = String()

  public var application: String = String()

  /// set to empty string to remove token
  public var activityToken: String = String()

  public var activityID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_SetActivityTokenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_SetActivityPushToStartTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwid: String = String()

  public var application: String = String()

  /// set to empty string to remove token
  public var activityPushToStartToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_SetActivityPushToStartTokenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_RichMediaActionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var application: String = String()

  public var hwid: String = String()

  public var userID: String = String()

  public var inappCode: String = String()

  public var richMediaCode: String = String()

  public var messageHash: String = String()

  public var platform: UInt32 = 0

  public var actionType: UInt32 = 0

  public var actionAttributes: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_DeviceApi_V2_RichMediaActionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pushwoosh.device_api.v2"

extension Pushwoosh_DeviceApi_V2_ApplicationOpenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplicationOpenRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}application\0\u{1}platform\0\u{1}language\0\u{3}app_version\0\u{3}device_model\0\u{3}os_version\0\u{3}sdk_version\0\u{3}push_alerts_enabled\0\u{1}timezone\0\u{3}time_sensitive_notifications\0\u{3}scheduled_summary\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.platform) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.deviceModel) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.sdkVersion) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._pushAlertsEnabled) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.timezone) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._timeSensitiveNotifications) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._scheduledSummary) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    if self.platform != 0 {
      try visitor.visitSingularUInt32Field(value: self.platform, fieldNumber: 3)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 4)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 5)
    }
    if !self.deviceModel.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceModel, fieldNumber: 6)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 7)
    }
    if !self.sdkVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.sdkVersion, fieldNumber: 8)
    }
    try { if let v = self._pushAlertsEnabled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.timezone.isEmpty {
      try visitor.visitSingularStringField(value: self.timezone, fieldNumber: 10)
    }
    try { if let v = self._timeSensitiveNotifications {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._scheduledSummary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_ApplicationOpenRequest, rhs: Pushwoosh_DeviceApi_V2_ApplicationOpenRequest) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.application != rhs.application {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.language != rhs.language {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.deviceModel != rhs.deviceModel {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.sdkVersion != rhs.sdkVersion {return false}
    if lhs._pushAlertsEnabled != rhs._pushAlertsEnabled {return false}
    if lhs.timezone != rhs.timezone {return false}
    if lhs._timeSensitiveNotifications != rhs._timeSensitiveNotifications {return false}
    if lhs._scheduledSummary != rhs._scheduledSummary {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_ApplicationOpenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplicationOpenResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}required_inapps\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pushwoosh_DeviceApi_V2_ApplicationOpenResponse.RequiredInApp>.self, value: &self.requiredInapps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requiredInapps.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pushwoosh_DeviceApi_V2_ApplicationOpenResponse.RequiredInApp>.self, value: self.requiredInapps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_ApplicationOpenResponse, rhs: Pushwoosh_DeviceApi_V2_ApplicationOpenResponse) -> Bool {
    if lhs.requiredInapps != rhs.requiredInapps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_ApplicationOpenResponse.RequiredInApp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Pushwoosh_DeviceApi_V2_ApplicationOpenResponse.protoMessageName + ".RequiredInApp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}updated\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.updated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if self.updated != 0 {
      try visitor.visitSingularInt32Field(value: self.updated, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_ApplicationOpenResponse.RequiredInApp, rhs: Pushwoosh_DeviceApi_V2_ApplicationOpenResponse.RequiredInApp) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.updated != rhs.updated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_SetBadgeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetBadgeRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}application\0\u{1}badge\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.badge) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    if self.badge != 0 {
      try visitor.visitSingularInt32Field(value: self.badge, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_SetBadgeRequest, rhs: Pushwoosh_DeviceApi_V2_SetBadgeRequest) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.application != rhs.application {return false}
    if lhs.badge != rhs.badge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_SetBadgeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetBadgeResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_SetBadgeResponse, rhs: Pushwoosh_DeviceApi_V2_SetBadgeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_PushStatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushStatRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}application\0\u{1}hash\0\u{1}platform\0\u{3}user_id\0\u{2}\u{2}metadata\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.platform) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 3)
    }
    if self.platform != 0 {
      try visitor.visitSingularUInt32Field(value: self.platform, fieldNumber: 4)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 5)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_PushStatRequest, rhs: Pushwoosh_DeviceApi_V2_PushStatRequest) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.application != rhs.application {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_PushStatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushStatResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_PushStatResponse, rhs: Pushwoosh_DeviceApi_V2_PushStatResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_MessageDeliveryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageDeliveryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}application\0\u{1}hash\0\u{1}platform\0\u{3}user_id\0\u{3}message_id\0\u{1}metadata\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.platform) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 3)
    }
    if self.platform != 0 {
      try visitor.visitSingularUInt32Field(value: self.platform, fieldNumber: 4)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 5)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 6)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_MessageDeliveryRequest, rhs: Pushwoosh_DeviceApi_V2_MessageDeliveryRequest) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.application != rhs.application {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_MessageDeliveryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageDeliveryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_MessageDeliveryResponse, rhs: Pushwoosh_DeviceApi_V2_MessageDeliveryResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_SetTagsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetTagsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}application\0\u{3}user_id\0\u{1}tags\0\u{1}platform\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._tags) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.platform) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    try { if let v = self._tags {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.platform != 0 {
      try visitor.visitSingularUInt32Field(value: self.platform, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_SetTagsRequest, rhs: Pushwoosh_DeviceApi_V2_SetTagsRequest) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.application != rhs.application {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs._tags != rhs._tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_SetTagsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetTagsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_SetTagsResponse, rhs: Pushwoosh_DeviceApi_V2_SetTagsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiRegisterDeviceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}application\0\u{1}email\0\u{3}sms_phone_number\0\u{3}whatsapp_phone_number\0\u{3}kakao_phone_number\0\u{3}line_token\0\u{3}telegram_user_id\0\u{1}language\0\u{1}timezone\0\u{1}city\0\u{1}country\0\u{1}state\0\u{1}tags\0\u{3}push_devices\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.smsPhoneNumber) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.whatsappPhoneNumber) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.kakaoPhoneNumber) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.lineToken) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.telegramUserID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.timezone) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.city) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.country) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 14: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.TagValue>.self, value: &self.tags) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.pushDevices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 3)
    }
    if !self.smsPhoneNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.smsPhoneNumber, fieldNumber: 4)
    }
    if !self.whatsappPhoneNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.whatsappPhoneNumber, fieldNumber: 5)
    }
    if !self.kakaoPhoneNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.kakaoPhoneNumber, fieldNumber: 6)
    }
    if !self.lineToken.isEmpty {
      try visitor.visitSingularStringField(value: self.lineToken, fieldNumber: 7)
    }
    if !self.telegramUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.telegramUserID, fieldNumber: 8)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 9)
    }
    if !self.timezone.isEmpty {
      try visitor.visitSingularStringField(value: self.timezone, fieldNumber: 10)
    }
    if !self.city.isEmpty {
      try visitor.visitSingularStringField(value: self.city, fieldNumber: 11)
    }
    if !self.country.isEmpty {
      try visitor.visitSingularStringField(value: self.country, fieldNumber: 12)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 13)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.TagValue>.self, value: self.tags, fieldNumber: 14)
    }
    if !self.pushDevices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pushDevices, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest, rhs: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.application != rhs.application {return false}
    if lhs.email != rhs.email {return false}
    if lhs.smsPhoneNumber != rhs.smsPhoneNumber {return false}
    if lhs.whatsappPhoneNumber != rhs.whatsappPhoneNumber {return false}
    if lhs.kakaoPhoneNumber != rhs.kakaoPhoneNumber {return false}
    if lhs.lineToken != rhs.lineToken {return false}
    if lhs.telegramUserID != rhs.telegramUserID {return false}
    if lhs.language != rhs.language {return false}
    if lhs.timezone != rhs.timezone {return false}
    if lhs.city != rhs.city {return false}
    if lhs.country != rhs.country {return false}
    if lhs.state != rhs.state {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.pushDevices != rhs.pushDevices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.TagValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.protoMessageName + ".TagValue"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}operation\0\u{1}value\0\u{1}values\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operation != .set {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.TagValue, rhs: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.TagValue) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.value != rhs.value {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.TagValue.Operation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OPERATION_SET\0\u{1}OPERATION_APPEND\0\u{1}OPERATION_REMOVE\0\u{1}OPERATION_INCREMENT\0")
}

extension Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.protoMessageName + ".PushDevice"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}platform\0\u{3}push_token\0\u{3}app_version\0\u{3}os_version\0\u{3}sdk_version\0\u{1}location\0\u{1}push\0\u{3}web_push\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pushToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.sdkVersion) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 8: try {
        var v: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.PushPlatformData?
        var hadOneofValue = false
        if let current = self.platformData {
          hadOneofValue = true
          if case .push(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.platformData = .push(v)
        }
      }()
      case 9: try {
        var v: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.WebPushPlatformData?
        var hadOneofValue = false
        if let current = self.platformData {
          hadOneofValue = true
          if case .webPush(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.platformData = .webPush(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if self.platform != .unspecified {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 2)
    }
    if !self.pushToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pushToken, fieldNumber: 3)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 4)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 5)
    }
    if !self.sdkVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.sdkVersion, fieldNumber: 6)
    }
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    switch self.platformData {
    case .push?: try {
      guard case .push(let v)? = self.platformData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .webPush?: try {
      guard case .webPush(let v)? = self.platformData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice, rhs: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.pushToken != rhs.pushToken {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.sdkVersion != rhs.sdkVersion {return false}
    if lhs._location != rhs._location {return false}
    if lhs.platformData != rhs.platformData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.Platform: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PLATFORM_UNSPECIFIED\0\u{1}IOS\0\u{2}\u{2}ANDROID\0\u{2}\u{4}OSX\0\u{1}WINDOWS\0\u{1}AMAZON\0\u{1}SAFARI\0\u{1}CHROME\0\u{1}FIREFOX\0\u{2}\u{5}HUAWEI_ANDROID\0\u{2}\u{3}WEB\0")
}

extension Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.protoMessageName + ".Location"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}lat\0\u{1}lon\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.lat) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.lon) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lat.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lat, fieldNumber: 1)
    }
    if self.lon.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lon, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.Location, rhs: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.Location) -> Bool {
    if lhs.lat != rhs.lat {return false}
    if lhs.lon != rhs.lon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.PushPlatformData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.protoMessageName + ".PushPlatformData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}push_alerts_enabled\0\u{3}device_model\0\u{3}application_sounds\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pushAlertsEnabled) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceModel) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.applicationSounds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pushAlertsEnabled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.deviceModel.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceModel, fieldNumber: 2)
    }
    if !self.applicationSounds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.applicationSounds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.PushPlatformData, rhs: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.PushPlatformData) -> Bool {
    if lhs._pushAlertsEnabled != rhs._pushAlertsEnabled {return false}
    if lhs.deviceModel != rhs.deviceModel {return false}
    if lhs.applicationSounds != rhs.applicationSounds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.WebPushPlatformData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.protoMessageName + ".WebPushPlatformData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}public_key\0\u{3}auth_token\0\u{1}browser\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.authToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.browser) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.authToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authToken, fieldNumber: 2)
    }
    if !self.browser.isEmpty {
      try visitor.visitSingularStringField(value: self.browser, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.WebPushPlatformData, rhs: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceRequest.PushDevice.WebPushPlatformData) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.authToken != rhs.authToken {return false}
    if lhs.browser != rhs.browser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_MultiRegisterDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiRegisterDeviceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceResponse, rhs: Pushwoosh_DeviceApi_V2_MultiRegisterDeviceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_GetPlatformConfigurationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPlatformConfigurationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}application\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.application) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_GetPlatformConfigurationRequest, rhs: Pushwoosh_DeviceApi_V2_GetPlatformConfigurationRequest) -> Bool {
    if lhs.application != rhs.application {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPlatformConfigurationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ios\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ios) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ios {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse, rhs: Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse) -> Bool {
    if lhs._ios != rhs._ios {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.protoMessageName + ".PlatformParamIOS"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}categories\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.categories) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.categories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.categories, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS, rhs: Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS) -> Bool {
    if lhs.categories != rhs.categories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS.Category: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS.protoMessageName + ".Category"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}category_id\0\u{1}buttons\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.categoryID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.buttons) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.categoryID != 0 {
      try visitor.visitSingularInt32Field(value: self.categoryID, fieldNumber: 1)
    }
    if !self.buttons.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buttons, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS.Category, rhs: Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS.Category) -> Bool {
    if lhs.categoryID != rhs.categoryID {return false}
    if lhs.buttons != rhs.buttons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS.Category.ButtonType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0BUTTON_TYPE_DEFAULT\0\u{1}BUTTON_TYPE_DESTRUCTIVE\0")
}

extension Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS.Category.StartApplication: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0START_APP_BACKGROUND\0\u{1}START_APP_FOREGROUND\0")
}

extension Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS.Category.Button: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS.Category.protoMessageName + ".Button"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}label\0\u{1}type\0\u{3}start_application\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.startApplication) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if self.type != .default {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if self.startApplication != .startAppBackground {
      try visitor.visitSingularEnumField(value: self.startApplication, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS.Category.Button, rhs: Pushwoosh_DeviceApi_V2_GetPlatformConfigurationResponse.PlatformParamIOS.Category.Button) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.label != rhs.label {return false}
    if lhs.type != rhs.type {return false}
    if lhs.startApplication != rhs.startApplication {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_RegisterDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterDeviceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}application\0\u{1}platform\0\u{3}push_token\0\u{3}user_id\0\u{1}language\0\u{3}app_version\0\u{3}device_model\0\u{3}os_version\0\u{3}sdk_version\0\u{3}push_alerts_enabled\0\u{1}timezone\0\u{3}time_sensitive_notifications\0\u{3}scheduled_summary\0\u{3}public_key\0\u{3}auth_token\0\u{3}fcm_token\0\u{3}fcm_push_set\0\u{1}sounds\0\u{1}tags\0\u{3}voip_push_token\0")

  fileprivate class _StorageClass {
    var _hwid: String = String()
    var _application: String = String()
    var _platform: UInt32 = 0
    var _pushToken: String = String()
    var _userID: String = String()
    var _language: String = String()
    var _appVersion: String = String()
    var _deviceModel: String = String()
    var _osVersion: String = String()
    var _sdkVersion: String = String()
    var _pushAlertsEnabled: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _timezone: String = String()
    var _timeSensitiveNotifications: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _scheduledSummary: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _publicKey: String = String()
    var _authToken: String = String()
    var _fcmToken: String = String()
    var _fcmPushSet: String = String()
    var _sounds: [String] = []
    var _tags: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _voipPushToken: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hwid = source._hwid
      _application = source._application
      _platform = source._platform
      _pushToken = source._pushToken
      _userID = source._userID
      _language = source._language
      _appVersion = source._appVersion
      _deviceModel = source._deviceModel
      _osVersion = source._osVersion
      _sdkVersion = source._sdkVersion
      _pushAlertsEnabled = source._pushAlertsEnabled
      _timezone = source._timezone
      _timeSensitiveNotifications = source._timeSensitiveNotifications
      _scheduledSummary = source._scheduledSummary
      _publicKey = source._publicKey
      _authToken = source._authToken
      _fcmToken = source._fcmToken
      _fcmPushSet = source._fcmPushSet
      _sounds = source._sounds
      _tags = source._tags
      _voipPushToken = source._voipPushToken
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._hwid) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._application) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._platform) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._pushToken) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._language) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._appVersion) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._deviceModel) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._osVersion) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._sdkVersion) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._pushAlertsEnabled) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._timezone) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._timeSensitiveNotifications) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._scheduledSummary) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._publicKey) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._authToken) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._fcmToken) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._fcmPushSet) }()
        case 19: try { try decoder.decodeRepeatedStringField(value: &_storage._sounds) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._tags) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._voipPushToken) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._hwid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hwid, fieldNumber: 1)
      }
      if !_storage._application.isEmpty {
        try visitor.visitSingularStringField(value: _storage._application, fieldNumber: 2)
      }
      if _storage._platform != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._platform, fieldNumber: 3)
      }
      if !_storage._pushToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pushToken, fieldNumber: 4)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 5)
      }
      if !_storage._language.isEmpty {
        try visitor.visitSingularStringField(value: _storage._language, fieldNumber: 6)
      }
      if !_storage._appVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appVersion, fieldNumber: 7)
      }
      if !_storage._deviceModel.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deviceModel, fieldNumber: 8)
      }
      if !_storage._osVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._osVersion, fieldNumber: 9)
      }
      if !_storage._sdkVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sdkVersion, fieldNumber: 10)
      }
      try { if let v = _storage._pushAlertsEnabled {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._timezone.isEmpty {
        try visitor.visitSingularStringField(value: _storage._timezone, fieldNumber: 12)
      }
      try { if let v = _storage._timeSensitiveNotifications {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._scheduledSummary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if !_storage._publicKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._publicKey, fieldNumber: 15)
      }
      if !_storage._authToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._authToken, fieldNumber: 16)
      }
      if !_storage._fcmToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fcmToken, fieldNumber: 17)
      }
      if !_storage._fcmPushSet.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fcmPushSet, fieldNumber: 18)
      }
      if !_storage._sounds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._sounds, fieldNumber: 19)
      }
      try { if let v = _storage._tags {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if !_storage._voipPushToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._voipPushToken, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_RegisterDeviceRequest, rhs: Pushwoosh_DeviceApi_V2_RegisterDeviceRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hwid != rhs_storage._hwid {return false}
        if _storage._application != rhs_storage._application {return false}
        if _storage._platform != rhs_storage._platform {return false}
        if _storage._pushToken != rhs_storage._pushToken {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._language != rhs_storage._language {return false}
        if _storage._appVersion != rhs_storage._appVersion {return false}
        if _storage._deviceModel != rhs_storage._deviceModel {return false}
        if _storage._osVersion != rhs_storage._osVersion {return false}
        if _storage._sdkVersion != rhs_storage._sdkVersion {return false}
        if _storage._pushAlertsEnabled != rhs_storage._pushAlertsEnabled {return false}
        if _storage._timezone != rhs_storage._timezone {return false}
        if _storage._timeSensitiveNotifications != rhs_storage._timeSensitiveNotifications {return false}
        if _storage._scheduledSummary != rhs_storage._scheduledSummary {return false}
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._authToken != rhs_storage._authToken {return false}
        if _storage._fcmToken != rhs_storage._fcmToken {return false}
        if _storage._fcmPushSet != rhs_storage._fcmPushSet {return false}
        if _storage._sounds != rhs_storage._sounds {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._voipPushToken != rhs_storage._voipPushToken {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_RegisterDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterDeviceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}iosCategories\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.iosCategories) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.iosCategories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.iosCategories, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_RegisterDeviceResponse, rhs: Pushwoosh_DeviceApi_V2_RegisterDeviceResponse) -> Bool {
    if lhs.iosCategories != rhs.iosCategories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_RegisterDeviceResponse.IOSCategory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Pushwoosh_DeviceApi_V2_RegisterDeviceResponse.protoMessageName + ".IOSCategory"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}categoryId\0\u{1}buttons\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.categoryID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.buttons) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.categoryID != 0 {
      try visitor.visitSingularInt32Field(value: self.categoryID, fieldNumber: 1)
    }
    if !self.buttons.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buttons, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_RegisterDeviceResponse.IOSCategory, rhs: Pushwoosh_DeviceApi_V2_RegisterDeviceResponse.IOSCategory) -> Bool {
    if lhs.categoryID != rhs.categoryID {return false}
    if lhs.buttons != rhs.buttons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_RegisterDeviceResponse.IOSCategory.Button: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Pushwoosh_DeviceApi_V2_RegisterDeviceResponse.IOSCategory.protoMessageName + ".Button"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}label\0\u{1}type\0\u{1}startApplication\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.startApplication) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 3)
    }
    if self.startApplication != 0 {
      try visitor.visitSingularInt32Field(value: self.startApplication, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_RegisterDeviceResponse.IOSCategory.Button, rhs: Pushwoosh_DeviceApi_V2_RegisterDeviceResponse.IOSCategory.Button) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.label != rhs.label {return false}
    if lhs.type != rhs.type {return false}
    if lhs.startApplication != rhs.startApplication {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_UnregisterDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnregisterDeviceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}application\0\u{1}hash\0\u{1}metadata\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_UnregisterDeviceRequest, rhs: Pushwoosh_DeviceApi_V2_UnregisterDeviceRequest) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.application != rhs.application {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_UnregisterDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnregisterDeviceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_UnregisterDeviceResponse, rhs: Pushwoosh_DeviceApi_V2_UnregisterDeviceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_DeleteDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteDeviceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}application\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_DeleteDeviceRequest, rhs: Pushwoosh_DeviceApi_V2_DeleteDeviceRequest) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.application != rhs.application {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_DeleteDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteDeviceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_DeleteDeviceResponse, rhs: Pushwoosh_DeviceApi_V2_DeleteDeviceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_DeleteUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteUserRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}application\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_DeleteUserRequest, rhs: Pushwoosh_DeviceApi_V2_DeleteUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.application != rhs.application {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_DeleteUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_DeleteUserResponse, rhs: Pushwoosh_DeviceApi_V2_DeleteUserResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_GetInAppsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInAppsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}application\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.application) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_GetInAppsRequest, rhs: Pushwoosh_DeviceApi_V2_GetInAppsRequest) -> Bool {
    if lhs.application != rhs.application {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_GetInAppsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInAppsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}inApps\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inApps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inApps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inApps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_GetInAppsResponse, rhs: Pushwoosh_DeviceApi_V2_GetInAppsResponse) -> Bool {
    if lhs.inApps != rhs.inApps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_GetInAppsResponse.InApp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Pushwoosh_DeviceApi_V2_GetInAppsResponse.protoMessageName + ".InApp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}url\0\u{1}code\0\u{1}layout\0\u{1}updated\0\u{1}closeButtonType\0\u{1}hash\0\u{1}required\0\u{1}priority\0\u{1}businessCase\0\u{1}gdpr\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.layout) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.updated) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.closeButtonType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.required) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.priority) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.businessCase) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.gdpr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 2)
    }
    if !self.layout.isEmpty {
      try visitor.visitSingularStringField(value: self.layout, fieldNumber: 3)
    }
    if self.updated != 0 {
      try visitor.visitSingularInt32Field(value: self.updated, fieldNumber: 4)
    }
    if self.closeButtonType != 0 {
      try visitor.visitSingularInt32Field(value: self.closeButtonType, fieldNumber: 5)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 6)
    }
    if self.required != false {
      try visitor.visitSingularBoolField(value: self.required, fieldNumber: 7)
    }
    if self.priority != 0 {
      try visitor.visitSingularInt32Field(value: self.priority, fieldNumber: 8)
    }
    if !self.businessCase.isEmpty {
      try visitor.visitSingularStringField(value: self.businessCase, fieldNumber: 9)
    }
    if !self.gdpr.isEmpty {
      try visitor.visitSingularStringField(value: self.gdpr, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_GetInAppsResponse.InApp, rhs: Pushwoosh_DeviceApi_V2_GetInAppsResponse.InApp) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.code != rhs.code {return false}
    if lhs.layout != rhs.layout {return false}
    if lhs.updated != rhs.updated {return false}
    if lhs.closeButtonType != rhs.closeButtonType {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.required != rhs.required {return false}
    if lhs.priority != rhs.priority {return false}
    if lhs.businessCase != rhs.businessCase {return false}
    if lhs.gdpr != rhs.gdpr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_SetAttributesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetAttributesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}application\0\u{1}key\0\u{3}encrypted_data\0\u{1}attributes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.encryptedData) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._attributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 3)
    }
    if !self.encryptedData.isEmpty {
      try visitor.visitSingularStringField(value: self.encryptedData, fieldNumber: 4)
    }
    try { if let v = self._attributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_SetAttributesRequest, rhs: Pushwoosh_DeviceApi_V2_SetAttributesRequest) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.application != rhs.application {return false}
    if lhs.key != rhs.key {return false}
    if lhs.encryptedData != rhs.encryptedData {return false}
    if lhs._attributes != rhs._attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_SetAttributesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetAttributesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_SetAttributesResponse, rhs: Pushwoosh_DeviceApi_V2_SetAttributesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_CheckDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckDeviceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}application\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_CheckDeviceRequest, rhs: Pushwoosh_DeviceApi_V2_CheckDeviceRequest) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.application != rhs.application {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_CheckDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckDeviceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}exist\0\u{3}push_token_exist\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.exist) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.pushTokenExist) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.exist != false {
      try visitor.visitSingularBoolField(value: self.exist, fieldNumber: 1)
    }
    if self.pushTokenExist != false {
      try visitor.visitSingularBoolField(value: self.pushTokenExist, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_CheckDeviceResponse, rhs: Pushwoosh_DeviceApi_V2_CheckDeviceResponse) -> Bool {
    if lhs.exist != rhs.exist {return false}
    if lhs.pushTokenExist != rhs.pushTokenExist {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_RegisterUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterUserRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{2}\u{2}application\0\u{3}user_id\0\u{1}platform\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.platform) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 3)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 4)
    }
    if self.platform != 0 {
      try visitor.visitSingularUInt32Field(value: self.platform, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_RegisterUserRequest, rhs: Pushwoosh_DeviceApi_V2_RegisterUserRequest) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.application != rhs.application {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_RegisterUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_RegisterUserResponse, rhs: Pushwoosh_DeviceApi_V2_RegisterUserResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_GetTagsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTagsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}application\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_GetTagsRequest, rhs: Pushwoosh_DeviceApi_V2_GetTagsRequest) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.application != rhs.application {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_GetTagsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTagsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_GetTagsResponse, rhs: Pushwoosh_DeviceApi_V2_GetTagsResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_EmailLinkClickRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmailLinkClickRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}application\0\u{3}redirect_link\0\u{3}original_link\0\u{3}original_title\0\u{3}template_code\0\u{1}hash\0\u{3}point_uuid\0\u{1}ip\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.redirectLink) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.originalLink) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.originalTitle) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.templateCode) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.pointUuid) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    if !self.redirectLink.isEmpty {
      try visitor.visitSingularStringField(value: self.redirectLink, fieldNumber: 3)
    }
    if !self.originalLink.isEmpty {
      try visitor.visitSingularStringField(value: self.originalLink, fieldNumber: 4)
    }
    if !self.originalTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.originalTitle, fieldNumber: 5)
    }
    if !self.templateCode.isEmpty {
      try visitor.visitSingularStringField(value: self.templateCode, fieldNumber: 6)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 7)
    }
    if !self.pointUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.pointUuid, fieldNumber: 8)
    }
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_EmailLinkClickRequest, rhs: Pushwoosh_DeviceApi_V2_EmailLinkClickRequest) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.application != rhs.application {return false}
    if lhs.redirectLink != rhs.redirectLink {return false}
    if lhs.originalLink != rhs.originalLink {return false}
    if lhs.originalTitle != rhs.originalTitle {return false}
    if lhs.templateCode != rhs.templateCode {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.pointUuid != rhs.pointUuid {return false}
    if lhs.ip != rhs.ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_EmailLinkClickResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmailLinkClickResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_EmailLinkClickResponse, rhs: Pushwoosh_DeviceApi_V2_EmailLinkClickResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_GetUnregisteredDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUnregisteredDevicesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}auth\0\u{1}application\0\u{3}date_from\0\u{3}date_to\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.auth) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dateFrom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.dateTo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.auth.isEmpty {
      try visitor.visitSingularStringField(value: self.auth, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    if !self.dateFrom.isEmpty {
      try visitor.visitSingularStringField(value: self.dateFrom, fieldNumber: 3)
    }
    if !self.dateTo.isEmpty {
      try visitor.visitSingularStringField(value: self.dateTo, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_GetUnregisteredDevicesRequest, rhs: Pushwoosh_DeviceApi_V2_GetUnregisteredDevicesRequest) -> Bool {
    if lhs.auth != rhs.auth {return false}
    if lhs.application != rhs.application {return false}
    if lhs.dateFrom != rhs.dateFrom {return false}
    if lhs.dateTo != rhs.dateTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_GetUnregisteredDevicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUnregisteredDevicesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwids\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.hwids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hwids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.hwids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_GetUnregisteredDevicesResponse, rhs: Pushwoosh_DeviceApi_V2_GetUnregisteredDevicesResponse) -> Bool {
    if lhs.hwids != rhs.hwids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_SetActivityTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetActivityTokenRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}application\0\u{3}activity_token\0\u{3}activity_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.activityToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    if !self.activityToken.isEmpty {
      try visitor.visitSingularStringField(value: self.activityToken, fieldNumber: 3)
    }
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_SetActivityTokenRequest, rhs: Pushwoosh_DeviceApi_V2_SetActivityTokenRequest) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.application != rhs.application {return false}
    if lhs.activityToken != rhs.activityToken {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_SetActivityTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetActivityTokenResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_SetActivityTokenResponse, rhs: Pushwoosh_DeviceApi_V2_SetActivityTokenResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_SetActivityPushToStartTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetActivityPushToStartTokenRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}application\0\u{3}activity_push_to_start_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.activityPushToStartToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    if !self.activityPushToStartToken.isEmpty {
      try visitor.visitSingularStringField(value: self.activityPushToStartToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_SetActivityPushToStartTokenRequest, rhs: Pushwoosh_DeviceApi_V2_SetActivityPushToStartTokenRequest) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.application != rhs.application {return false}
    if lhs.activityPushToStartToken != rhs.activityPushToStartToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_SetActivityPushToStartTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetActivityPushToStartTokenResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_SetActivityPushToStartTokenResponse, rhs: Pushwoosh_DeviceApi_V2_SetActivityPushToStartTokenResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_RichMediaActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RichMediaActionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}application\0\u{1}hwid\0\u{3}user_id\0\u{3}inapp_code\0\u{3}rich_media_code\0\u{3}message_hash\0\u{1}platform\0\u{3}action_type\0\u{3}action_attributes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.inappCode) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.richMediaCode) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.messageHash) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.platform) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.actionType) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.actionAttributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 1)
    }
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    if !self.inappCode.isEmpty {
      try visitor.visitSingularStringField(value: self.inappCode, fieldNumber: 4)
    }
    if !self.richMediaCode.isEmpty {
      try visitor.visitSingularStringField(value: self.richMediaCode, fieldNumber: 5)
    }
    if !self.messageHash.isEmpty {
      try visitor.visitSingularStringField(value: self.messageHash, fieldNumber: 6)
    }
    if self.platform != 0 {
      try visitor.visitSingularUInt32Field(value: self.platform, fieldNumber: 7)
    }
    if self.actionType != 0 {
      try visitor.visitSingularUInt32Field(value: self.actionType, fieldNumber: 8)
    }
    if !self.actionAttributes.isEmpty {
      try visitor.visitSingularStringField(value: self.actionAttributes, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_RichMediaActionRequest, rhs: Pushwoosh_DeviceApi_V2_RichMediaActionRequest) -> Bool {
    if lhs.application != rhs.application {return false}
    if lhs.hwid != rhs.hwid {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.inappCode != rhs.inappCode {return false}
    if lhs.richMediaCode != rhs.richMediaCode {return false}
    if lhs.messageHash != rhs.messageHash {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.actionType != rhs.actionType {return false}
    if lhs.actionAttributes != rhs.actionAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_DeviceApi_V2_RichMediaActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RichMediaActionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_DeviceApi_V2_RichMediaActionResponse, rhs: Pushwoosh_DeviceApi_V2_RichMediaActionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
