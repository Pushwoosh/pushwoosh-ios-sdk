// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pushwoosh/post_event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Pushwoosh_PostEventApi_PostEventRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hwid: String = String()

  public var application: String = String()

  public var event: String = String()

  public var userID: String = String()

  public var platform: Int32 = 0

  public var timestamp: Int64 = 0

  public var attributes: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _attributes ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_attributes = newValue}
  }
  /// Returns true if `attributes` has been explicitly set.
  public var hasAttributes: Bool {return self._attributes != nil}
  /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
  public mutating func clearAttributes() {self._attributes = nil}

  public var sdkVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _attributes: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Pushwoosh_PostEventApi_RichMedia: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var url: String = String()

  public var code: String = String()

  /// updated_at (legacy name)
  public var ts: Int32 = 0

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pushwoosh_PostEventApi_PostEventResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: String = String()

  public var required: Bool = false

  public var richmedia: Pushwoosh_PostEventApi_RichMedia {
    get {return _richmedia ?? Pushwoosh_PostEventApi_RichMedia()}
    set {_richmedia = newValue}
  }
  /// Returns true if `richmedia` has been explicitly set.
  public var hasRichmedia: Bool {return self._richmedia != nil}
  /// Clears the value of `richmedia`. Subsequent reads from it will return its default value.
  public mutating func clearRichmedia() {self._richmedia = nil}

  public var messageHash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _richmedia: Pushwoosh_PostEventApi_RichMedia? = nil
}

public struct Pushwoosh_PostEventApi_ShowInappMessageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var application: String = String()

  public var inapp: String = String()

  public var expiryDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiryDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiryDate = newValue}
  }
  /// Returns true if `expiryDate` has been explicitly set.
  public var hasExpiryDate: Bool {return self._expiryDate != nil}
  /// Clears the value of `expiryDate`. Subsequent reads from it will return its default value.
  public mutating func clearExpiryDate() {self._expiryDate = nil}

  public var campaignID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expiryDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pushwoosh_PostEventApi_ShowInappMessageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pushwoosh.post_event_api"

extension Pushwoosh_PostEventApi_PostEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostEventRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hwid\0\u{1}application\0\u{1}event\0\u{3}user_id\0\u{1}platform\0\u{1}timestamp\0\u{1}attributes\0\u{3}sdk_version\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hwid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.event) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.platform) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._attributes) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.sdkVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hwid.isEmpty {
      try visitor.visitSingularStringField(value: self.hwid, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    if !self.event.isEmpty {
      try visitor.visitSingularStringField(value: self.event, fieldNumber: 3)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 4)
    }
    if self.platform != 0 {
      try visitor.visitSingularInt32Field(value: self.platform, fieldNumber: 5)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 6)
    }
    try { if let v = self._attributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.sdkVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.sdkVersion, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_PostEventApi_PostEventRequest, rhs: Pushwoosh_PostEventApi_PostEventRequest) -> Bool {
    if lhs.hwid != rhs.hwid {return false}
    if lhs.application != rhs.application {return false}
    if lhs.event != rhs.event {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._attributes != rhs._attributes {return false}
    if lhs.sdkVersion != rhs.sdkVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_PostEventApi_RichMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RichMedia"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}url\0\u{1}code\0\u{1}ts\0\u{1}hash\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.ts) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 2)
    }
    if self.ts != 0 {
      try visitor.visitSingularInt32Field(value: self.ts, fieldNumber: 3)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_PostEventApi_RichMedia, rhs: Pushwoosh_PostEventApi_RichMedia) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.code != rhs.code {return false}
    if lhs.ts != rhs.ts {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_PostEventApi_PostEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostEventResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}required\0\u{1}richmedia\0\u{3}message_hash\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.required) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._richmedia) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.messageHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if self.required != false {
      try visitor.visitSingularBoolField(value: self.required, fieldNumber: 2)
    }
    try { if let v = self._richmedia {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.messageHash.isEmpty {
      try visitor.visitSingularStringField(value: self.messageHash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_PostEventApi_PostEventResponse, rhs: Pushwoosh_PostEventApi_PostEventResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.required != rhs.required {return false}
    if lhs._richmedia != rhs._richmedia {return false}
    if lhs.messageHash != rhs.messageHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_PostEventApi_ShowInappMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShowInappMessageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}application\0\u{1}inapp\0\u{3}expiry_date\0\u{3}campaign_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.inapp) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expiryDate) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.campaignID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 2)
    }
    if !self.inapp.isEmpty {
      try visitor.visitSingularStringField(value: self.inapp, fieldNumber: 3)
    }
    try { if let v = self._expiryDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.campaignID != 0 {
      try visitor.visitSingularUInt64Field(value: self.campaignID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_PostEventApi_ShowInappMessageRequest, rhs: Pushwoosh_PostEventApi_ShowInappMessageRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.application != rhs.application {return false}
    if lhs.inapp != rhs.inapp {return false}
    if lhs._expiryDate != rhs._expiryDate {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pushwoosh_PostEventApi_ShowInappMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShowInappMessageResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pushwoosh_PostEventApi_ShowInappMessageResponse, rhs: Pushwoosh_PostEventApi_ShowInappMessageResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
